/** winioctl.d

Converted from 'winioctl.h'.

Version: V7.0
Authors: Koji Kishita
*/
module c.windows.winioctl;


import c.windows.windef;
import c.windows.winnt;
import c.windows.guiddef;

mixin DEFINE_GUID!("GUID_DEVINTERFACE_DISK", 0x53f56307L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
mixin DEFINE_GUID!("GUID_DEVINTERFACE_CDROM", 0x53f56308L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
mixin DEFINE_GUID!("GUID_DEVINTERFACE_PARTITION", 0x53f5630aL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
mixin DEFINE_GUID!("GUID_DEVINTERFACE_TAPE", 0x53f5630bL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
mixin DEFINE_GUID!("GUID_DEVINTERFACE_WRITEONCEDISK", 0x53f5630cL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
mixin DEFINE_GUID!("GUID_DEVINTERFACE_VOLUME", 0x53f5630dL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
mixin DEFINE_GUID!("GUID_DEVINTERFACE_MEDIUMCHANGER", 0x53f56310L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
mixin DEFINE_GUID!("GUID_DEVINTERFACE_FLOPPY", 0x53f56311L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
mixin DEFINE_GUID!("GUID_DEVINTERFACE_CDCHANGER", 0x53f56312L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
mixin DEFINE_GUID!("GUID_DEVINTERFACE_STORAGEPORT", 0x2accfe60L, 0xc130, 0x11d2, 0xb0, 0x82, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);

//WDI_STORAGE_PREDICT_FAILURE_DPS_GUID {0xe9f2d03aL, 0x747c, 0x41c2, {0xbb, 0x9a, 0x02, 0xc6, 0x2b, 0x6d, 0x5f, 0xcb}};

mixin DEFINE_GUID!("GUID_DEVINTERFACE_HIDDEN_VOLUME", 0x7f108a28L, 0x9833, 0x4b3b, 0xb7, 0x80, 0x2c, 0x6b, 0x5f, 0xa5, 0xc0, 0x62);
mixin DEFINE_GUID!("GUID_DEVINTERFACE_COMPORT", 0x86e0d1e0L, 0x8089, 0x11d0, 0x9c, 0xe4, 0x08, 0x00, 0x3e, 0x30, 0x1f, 0x73);
mixin DEFINE_GUID!("GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR", 0x4D36E978L, 0xE325, 0x11CE, 0xBF, 0xC1, 0x08, 0x00, 0x2B, 0xE1, 0x03, 0x18);

alias GUID_DEVINTERFACE_DISK DiskClassGuid;
alias GUID_DEVINTERFACE_CDROM CdRomClassGuid;
alias GUID_DEVINTERFACE_PARTITION PartitionClassGuid;
alias GUID_DEVINTERFACE_TAPE TapeClassGuid;
alias GUID_DEVINTERFACE_WRITEONCEDISK WriteOnceDiskClassGuid;
alias GUID_DEVINTERFACE_VOLUME VolumeClassGuid;
alias GUID_DEVINTERFACE_MEDIUMCHANGER MediumChangerClassGuid;
alias GUID_DEVINTERFACE_FLOPPY FloppyClassGuid;
alias GUID_DEVINTERFACE_CDCHANGER CdChangerClassGuid;
alias GUID_DEVINTERFACE_STORAGEPORT StoragePortClassGuid;
alias GUID_DEVINTERFACE_HIDDEN_VOLUME HiddenVolumeClassGuid;

alias GUID_DEVINTERFACE_COMPORT GUID_CLASS_COMPORT;
alias GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR GUID_SERENUM_BUS_ENUMERATOR;


alias DWORD DEVICE_TYPE;

enum {
	FILE_DEVICE_BEEP                = 0x00000001,
	FILE_DEVICE_CD_ROM              = 0x00000002,
	FILE_DEVICE_CD_ROM_FILE_SYSTEM  = 0x00000003,
	FILE_DEVICE_CONTROLLER          = 0x00000004,
	FILE_DEVICE_DATALINK            = 0x00000005,
	FILE_DEVICE_DFS                 = 0x00000006,
	FILE_DEVICE_DISK                = 0x00000007,
	FILE_DEVICE_DISK_FILE_SYSTEM    = 0x00000008,
	FILE_DEVICE_FILE_SYSTEM         = 0x00000009,
	FILE_DEVICE_INPORT_PORT         = 0x0000000a,
	FILE_DEVICE_KEYBOARD            = 0x0000000b,
	FILE_DEVICE_MAILSLOT            = 0x0000000c,
	FILE_DEVICE_MIDI_IN             = 0x0000000d,
	FILE_DEVICE_MIDI_OUT            = 0x0000000e,
	FILE_DEVICE_MOUSE               = 0x0000000f,
	FILE_DEVICE_MULTI_UNC_PROVIDER  = 0x00000010,
	FILE_DEVICE_NAMED_PIPE          = 0x00000011,
	FILE_DEVICE_NETWORK             = 0x00000012,
	FILE_DEVICE_NETWORK_BROWSER     = 0x00000013,
	FILE_DEVICE_NETWORK_FILE_SYSTEM = 0x00000014,
	FILE_DEVICE_NULL                = 0x00000015,
	FILE_DEVICE_PARALLEL_PORT       = 0x00000016,
	FILE_DEVICE_PHYSICAL_NETCARD    = 0x00000017,
	FILE_DEVICE_PRINTER             = 0x00000018,
	FILE_DEVICE_SCANNER             = 0x00000019,
	FILE_DEVICE_SERIAL_MOUSE_PORT   = 0x0000001a,
	FILE_DEVICE_SERIAL_PORT         = 0x0000001b,
	FILE_DEVICE_SCREEN              = 0x0000001c,
	FILE_DEVICE_SOUND               = 0x0000001d,
	FILE_DEVICE_STREAMS             = 0x0000001e,
	FILE_DEVICE_TAPE                = 0x0000001f,
	FILE_DEVICE_TAPE_FILE_SYSTEM    = 0x00000020,
	FILE_DEVICE_TRANSPORT           = 0x00000021,
	FILE_DEVICE_UNKNOWN             = 0x00000022,
	FILE_DEVICE_VIDEO               = 0x00000023,
	FILE_DEVICE_VIRTUAL_DISK        = 0x00000024,
	FILE_DEVICE_WAVE_IN             = 0x00000025,
	FILE_DEVICE_WAVE_OUT            = 0x00000026,
	FILE_DEVICE_8042_PORT           = 0x00000027,
	FILE_DEVICE_NETWORK_REDIRECTOR  = 0x00000028,
	FILE_DEVICE_BATTERY             = 0x00000029,
	FILE_DEVICE_BUS_EXTENDER        = 0x0000002a,
	FILE_DEVICE_MODEM               = 0x0000002b,
	FILE_DEVICE_VDM                 = 0x0000002c,
	FILE_DEVICE_MASS_STORAGE        = 0x0000002d,
	FILE_DEVICE_SMB                 = 0x0000002e,
	FILE_DEVICE_KS                  = 0x0000002f,
	FILE_DEVICE_CHANGER             = 0x00000030,
	FILE_DEVICE_SMARTCARD           = 0x00000031,
	FILE_DEVICE_ACPI                = 0x00000032,
	FILE_DEVICE_DVD                 = 0x00000033,
	FILE_DEVICE_FULLSCREEN_VIDEO    = 0x00000034,
	FILE_DEVICE_DFS_FILE_SYSTEM     = 0x00000035,
	FILE_DEVICE_DFS_VOLUME          = 0x00000036,
	FILE_DEVICE_SERENUM             = 0x00000037,
	FILE_DEVICE_TERMSRV             = 0x00000038,
	FILE_DEVICE_KSEC                = 0x00000039,
	FILE_DEVICE_FIPS                = 0x0000003A,
	FILE_DEVICE_INFINIBAND          = 0x0000003B,
	FILE_DEVICE_VMBUS               = 0x0000003E,
	FILE_DEVICE_CRYPT_PROVIDER      = 0x0000003F,
	FILE_DEVICE_WPD                 = 0x00000040,
	FILE_DEVICE_BLUETOOTH           = 0x00000041,
	FILE_DEVICE_MT_COMPOSITE        = 0x00000042,
	FILE_DEVICE_MT_TRANSPORT        = 0x00000043,
	FILE_DEVICE_BIOMETRIC           = 0x00000044,
	FILE_DEVICE_PMI                 = 0x00000045,
}

pure nothrow
DWORD CTL_CODE(DWORD DeviceType, DWORD Function, DWORD Method, DWORD Access)
{
	return (DeviceType << 16) | (Access << 14) | (Function << 2) | Method;
}

pure nothrow
DWORD DEVICE_TYPE_FROM_CTL_CODE(DWORD ctrlCode)
{
	return (ctrlCode & 0xffff0000) >> 16;
}

pure nothrow
DWORD METHOD_FROM_CTL_CODE(DWORD ctrlCode)
{
	return ctrlCode & 3;
}

enum {
	METHOD_BUFFERED             = 0,
	METHOD_IN_DIRECT            = 1,
	METHOD_OUT_DIRECT           = 2,
	METHOD_NEITHER              = 3,
	METHOD_DIRECT_TO_HARDWARE   = METHOD_IN_DIRECT,
	METHOD_DIRECT_FROM_HARDWARE = METHOD_OUT_DIRECT,
}

enum {
	FILE_ANY_ACCESS     = 0,
	FILE_SPECIAL_ACCESS = FILE_ANY_ACCESS,
	FILE_READ_ACCESS    = 0x0001,
	FILE_WRITE_ACCESS   = 0x0002,
}

version(all){//_NTDDSTOR_H_
	extern(C){

	alias FILE_DEVICE_MASS_STORAGE IOCTL_STORAGE_BASE;

	enum {
		IOCTL_STORAGE_CHECK_VERIFY                = CTL_CODE(IOCTL_STORAGE_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_STORAGE_CHECK_VERIFY2               = CTL_CODE(IOCTL_STORAGE_BASE, 0x0200, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_STORAGE_MEDIA_REMOVAL               = CTL_CODE(IOCTL_STORAGE_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_STORAGE_EJECT_MEDIA                 = CTL_CODE(IOCTL_STORAGE_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_STORAGE_LOAD_MEDIA                  = CTL_CODE(IOCTL_STORAGE_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_STORAGE_LOAD_MEDIA2                 = CTL_CODE(IOCTL_STORAGE_BASE, 0x0203, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_STORAGE_RESERVE                     = CTL_CODE(IOCTL_STORAGE_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_STORAGE_RELEASE                     = CTL_CODE(IOCTL_STORAGE_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_STORAGE_FIND_NEW_DEVICES            = CTL_CODE(IOCTL_STORAGE_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_STORAGE_EJECTION_CONTROL            = CTL_CODE(IOCTL_STORAGE_BASE, 0x0250, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_STORAGE_MCN_CONTROL                 = CTL_CODE(IOCTL_STORAGE_BASE, 0x0251, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_STORAGE_GET_MEDIA_TYPES             = CTL_CODE(IOCTL_STORAGE_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_STORAGE_GET_MEDIA_TYPES_EX          = CTL_CODE(IOCTL_STORAGE_BASE, 0x0301, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER     = CTL_CODE(IOCTL_STORAGE_BASE, 0x0304, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_STORAGE_GET_HOTPLUG_INFO            = CTL_CODE(IOCTL_STORAGE_BASE, 0x0305, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_STORAGE_SET_HOTPLUG_INFO            = CTL_CODE(IOCTL_STORAGE_BASE, 0x0306, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
		IOCTL_STORAGE_RESET_BUS                   = CTL_CODE(IOCTL_STORAGE_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_STORAGE_RESET_DEVICE                = CTL_CODE(IOCTL_STORAGE_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_STORAGE_BREAK_RESERVATION           = CTL_CODE(IOCTL_STORAGE_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_STORAGE_PERSISTENT_RESERVE_IN       = CTL_CODE(IOCTL_STORAGE_BASE, 0x0406, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_STORAGE_PERSISTENT_RESERVE_OUT      = CTL_CODE(IOCTL_STORAGE_BASE, 0x0407, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
		IOCTL_STORAGE_GET_DEVICE_NUMBER           = CTL_CODE(IOCTL_STORAGE_BASE, 0x0420, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_STORAGE_PREDICT_FAILURE             = CTL_CODE(IOCTL_STORAGE_BASE, 0x0440, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_STORAGE_READ_CAPACITY               = CTL_CODE(IOCTL_STORAGE_BASE, 0x0450, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_STORAGE_QUERY_PROPERTY              = CTL_CODE(IOCTL_STORAGE_BASE, 0x0500, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES  = CTL_CODE(IOCTL_STORAGE_BASE, 0x0501, METHOD_BUFFERED, FILE_WRITE_ACCESS),
		IOCTL_STORAGE_GET_BC_PROPERTIES           = CTL_CODE(IOCTL_STORAGE_BASE, 0x0600, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_STORAGE_ALLOCATE_BC_STREAM          = CTL_CODE(IOCTL_STORAGE_BASE, 0x0601, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
		IOCTL_STORAGE_FREE_BC_STREAM              = CTL_CODE(IOCTL_STORAGE_BASE, 0x0602, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
		IOCTL_STORAGE_CHECK_PRIORITY_HINT_SUPPORT = CTL_CODE(IOCTL_STORAGE_BASE, 0x0620, METHOD_BUFFERED, FILE_ANY_ACCESS),
		OBSOLETE_IOCTL_STORAGE_RESET_BUS          = CTL_CODE(IOCTL_STORAGE_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
		OBSOLETE_IOCTL_STORAGE_RESET_DEVICE       = CTL_CODE(IOCTL_STORAGE_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
	}

	struct STORAGE_HOTPLUG_INFO {
		DWORD Size;
		BOOLEAN MediaRemovable;
		BOOLEAN MediaHotplug;
		BOOLEAN DeviceHotplug;
		BOOLEAN WriteCacheEnableOverride;
	}
	alias STORAGE_HOTPLUG_INFO* PSTORAGE_HOTPLUG_INFO;

	struct STORAGE_DEVICE_NUMBER {
		DEVICE_TYPE DeviceType;
		DWORD DeviceNumber;
		DWORD PartitionNumber;
	}
	alias STORAGE_DEVICE_NUMBER* PSTORAGE_DEVICE_NUMBER;

	struct STORAGE_BUS_RESET_REQUEST {
		BYTE PathId;
	}
	alias STORAGE_BUS_RESET_REQUEST* PSTORAGE_BUS_RESET_REQUEST;

	struct STORAGE_BREAK_RESERVATION_REQUEST {
		DWORD Length;
		BYTE _unused;
		BYTE PathId;
		BYTE TargetId;
		BYTE Lun;
	}
	alias STORAGE_BREAK_RESERVATION_REQUEST* PSTORAGE_BREAK_RESERVATION_REQUEST;

	struct PREVENT_MEDIA_REMOVAL {
		BOOLEAN PreventMediaRemoval;
	}
	alias PREVENT_MEDIA_REMOVAL* PPREVENT_MEDIA_REMOVAL;

	struct CLASS_MEDIA_CHANGE_CONTEXT {
		DWORD MediaChangeCount;
		DWORD NewState;
	}
	alias CLASS_MEDIA_CHANGE_CONTEXT* PCLASS_MEDIA_CHANGE_CONTEXT;

	struct TAPE_STATISTICS {
		DWORD Version;
		DWORD Flags;
		LARGE_INTEGER RecoveredWrites;
		LARGE_INTEGER UnrecoveredWrites;
		LARGE_INTEGER RecoveredReads;
		LARGE_INTEGER UnrecoveredReads;
		BYTE CompressionRatioReads;
		BYTE CompressionRatioWrites;
	}
	alias TAPE_STATISTICS* PTAPE_STATISTICS;

	enum {
		RECOVERED_WRITES_VALID       = 0x00000001,
		UNRECOVERED_WRITES_VALID     = 0x00000002,
		RECOVERED_READS_VALID        = 0x00000004,
		UNRECOVERED_READS_VALID      = 0x00000008,
		WRITE_COMPRESSION_INFO_VALID = 0x00000010,
		READ_COMPRESSION_INFO_VALID  = 0x00000020,
	}

	struct TAPE_GET_STATISTICS {
		DWORD Operation;
	}
	alias TAPE_GET_STATISTICS* PTAPE_GET_STATISTICS;

	enum {
		TAPE_RETURN_STATISTICS = 0,
		TAPE_RETURN_ENV_INFO   = 1,
		TAPE_RESET_STATISTICS  = 2,
	}

	enum {
		DDS_4mm = 0x20,
		MiniQic,
		Travan,
		QIC,
		MP_8mm,
		AME_8mm,
		AIT1_8mm,
		DLT,
		NCTP,
		IBM_3480,
		IBM_3490E,
		IBM_Magstar_3590,
		IBM_Magstar_MP,
		STK_DATA_D3,
		SONY_DTF,
		DV_6mm,
		DMI,
		SONY_D2,
		CLEANER_CARTRIDGE,
		CD_ROM,
		CD_R,
		CD_RW,
		DVD_ROM,
		DVD_R,
		DVD_RW,
		MO_3_RW,
		MO_5_WO,
		MO_5_RW,
		MO_5_LIMDOW,
		PC_5_WO,
		PC_5_RW,
		PD_5_RW,
		ABL_5_WO,
		PINNACLE_APEX_5_RW,
		SONY_12_WO,
		PHILIPS_12_WO,
		HITACHI_12_WO,
		CYGNET_12_WO,
		KODAK_14_WO,
		MO_NFR_525,
		NIKON_12_RW,
		IOMEGA_ZIP,
		IOMEGA_JAZ,
		SYQUEST_EZ135,
		SYQUEST_EZFLYER,
		SYQUEST_SYJET,
		AVATAR_F2,
		MP2_8mm,
		DST_S,
		DST_M,
		DST_L,
		VXATape_1,
		VXATape_2,
		//(NTDDI_VERSION < NTDDI_WINXP)
		//	STK_EAGLE,
		//else
			STK_9840,
		LTO_Ultrium,
		LTO_Accelis,
		DVD_RAM,
		AIT_8mm,
		ADR_1,
		ADR_2,
		STK_9940,
		SAIT,
		VXATape
	}
	alias int STORAGE_MEDIA_TYPE;
	alias STORAGE_MEDIA_TYPE* PSTORAGE_MEDIA_TYPE;

	enum {
		MEDIA_ERASEABLE         = 0x00000001,
		MEDIA_WRITE_ONCE        = 0x00000002,
		MEDIA_READ_ONLY         = 0x00000004,
		MEDIA_READ_WRITE        = 0x00000008,
		MEDIA_WRITE_PROTECTED   = 0x00000100,
		MEDIA_CURRENTLY_MOUNTED = 0x80000000,
	}

	enum {
		BusTypeUnknown = 0x00,
		BusTypeScsi,
		BusTypeAtapi,
		BusTypeAta,
		BusType1394,
		BusTypeSsa,
		BusTypeFibre,
		BusTypeUsb,
		BusTypeRAID,
		BusTypeiScsi,
		BusTypeSas,
		BusTypeSata,
		BusTypeSd,
		BusTypeMmc,
		BusTypeVirtual,
		BusTypeFileBackedVirtual,
		BusTypeMax,
		BusTypeMaxReserved = 0x7F
	}
	alias int STORAGE_BUS_TYPE;
	alias STORAGE_BUS_TYPE* PSTORAGE_BUS_TYPE;

	struct DEVICE_MEDIA_INFO {
		union DeviceSpecific {
			struct DiskInfo_ {
				LARGE_INTEGER Cylinders;
				STORAGE_MEDIA_TYPE MediaType;
				DWORD TracksPerCylinder;
				DWORD SectorsPerTrack;
				DWORD BytesPerSector;
				DWORD NumberMediaSides;
				DWORD MediaCharacteristics;
			}
			DiskInfo_ DiskInfo;

			struct RemovableDiskInfo_ {
				LARGE_INTEGER Cylinders;
				STORAGE_MEDIA_TYPE MediaType;
				DWORD TracksPerCylinder;
				DWORD SectorsPerTrack;
				DWORD BytesPerSector;
				DWORD NumberMediaSides;
				DWORD MediaCharacteristics;
			}
			RemovableDiskInfo_ RemovableDiskInfo;

			struct TapeInfo_ {
				STORAGE_MEDIA_TYPE MediaType;
				DWORD MediaCharacteristics;
				DWORD CurrentBlockSize;
				STORAGE_BUS_TYPE BusType;

				union BusSpecificData{
					struct ScsiInformation_ {
						BYTE MediumType;
						BYTE DensityCode;
					}
					ScsiInformation_ ScsiInformation;
				}
			}
			TapeInfo_ TapeInfo;
		}
	}
	alias DEVICE_MEDIA_INFO* PDEVICE_MEDIA_INFO;

	struct GET_MEDIA_TYPES {
		DWORD DeviceType;
		DWORD MediaInfoCount;
		DEVICE_MEDIA_INFO[1] MediaInfo;
	}
	alias GET_MEDIA_TYPES* PGET_MEDIA_TYPES;

	struct STORAGE_PREDICT_FAILURE {
		DWORD PredictFailure;
		BYTE[512] VendorSpecific;
	}
	alias STORAGE_PREDICT_FAILURE* PSTORAGE_PREDICT_FAILURE;

	enum STORAGE_QUERY_TYPE {
		PropertyStandardQuery = 0,
		PropertyExistsQuery,
		PropertyMaskQuery,
		PropertyQueryMaxDefined
	}
	alias STORAGE_QUERY_TYPE* PSTORAGE_QUERY_TYPE;

	enum {
		StorageDeviceProperty = 0,
		StorageAdapterProperty,
		StorageDeviceIdProperty,
		StorageDeviceUniqueIdProperty,
		StorageDeviceWriteCacheProperty,
		StorageMiniportProperty,
		StorageAccessAlignmentProperty,
		StorageDeviceSeekPenaltyProperty,
		StorageDeviceTrimProperty,
		StorageDeviceWriteAggregationProperty
	}
	alias int STORAGE_PROPERTY_ID;
	alias STORAGE_PROPERTY_ID* PSTORAGE_PROPERTY_ID;

	struct STORAGE_PROPERTY_QUERY {
		STORAGE_PROPERTY_ID PropertyId;
		STORAGE_QUERY_TYPE QueryType;
		BYTE[1] AdditionalParameters;
	}
	alias STORAGE_PROPERTY_QUERY* PSTORAGE_PROPERTY_QUERY;

	struct STORAGE_DESCRIPTOR_HEADER {
		DWORD Version;
		DWORD Size;
	}
	alias STORAGE_DESCRIPTOR_HEADER* PSTORAGE_DESCRIPTOR_HEADER;

	struct STORAGE_DEVICE_DESCRIPTOR {
		DWORD Version;
		DWORD Size;
		BYTE DeviceType;
		BYTE DeviceTypeModifier;
		BOOLEAN RemovableMedia;
		BOOLEAN CommandQueueing;
		DWORD VendorIdOffset;
		DWORD ProductIdOffset;
		DWORD ProductRevisionOffset;
		DWORD SerialNumberOffset;
		STORAGE_BUS_TYPE BusType;
		DWORD RawPropertiesLength;
		BYTE[1] RawDeviceProperties;
	}
	alias STORAGE_DEVICE_DESCRIPTOR* PSTORAGE_DEVICE_DESCRIPTOR;

	struct STORAGE_ADAPTER_DESCRIPTOR {
		DWORD Version;
		DWORD Size;
		DWORD MaximumTransferLength;
		DWORD MaximumPhysicalPages;
		DWORD AlignmentMask;
		BOOLEAN AdapterUsesPio;
		BOOLEAN AdapterScansDown;
		BOOLEAN CommandQueueing;
		BOOLEAN AcceleratedTransfer;
		//(NTDDI_VERSION < NTDDI_WINXP)
		//	BOOLEAN BusType;
		//else
		BYTE BusType;
		WORD BusMajorVersion;
		WORD BusMinorVersion;
	}
	alias STORAGE_ADAPTER_DESCRIPTOR* PSTORAGE_ADAPTER_DESCRIPTOR;

	struct STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR {
		DWORD Version;
		DWORD Size;
		DWORD BytesPerCacheLine;
		DWORD BytesOffsetForCacheAlignment;
		DWORD BytesPerLogicalSector;
		DWORD BytesPerPhysicalSector;
		DWORD BytesOffsetForSectorAlignment;
	}
	alias STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR* PSTORAGE_ACCESS_ALIGNMENT_DESCRIPTOR;

	enum {
		StoragePortCodeSetReserved = 0,
		StoragePortCodeSetStorport = 1,
		StoragePortCodeSetSCSIport = 2
	}
	alias int STORAGE_PORT_CODE_SET;
	alias STORAGE_PORT_CODE_SET* PSTORAGE_PORT_CODE_SET;

	struct STORAGE_MINIPORT_DESCRIPTOR {
		DWORD Version;
		DWORD Size;
		STORAGE_PORT_CODE_SET Portdriver;
		BOOLEAN LUNResetSupported;
		BOOLEAN TargetResetSupported;
	}
	alias STORAGE_MINIPORT_DESCRIPTOR* PSTORAGE_MINIPORT_DESCRIPTOR;

	enum {
		StorageIdCodeSetReserved = 0,
		StorageIdCodeSetBinary = 1,
		StorageIdCodeSetAscii = 2,
		StorageIdCodeSetUtf8 = 3
	}
	alias int STORAGE_IDENTIFIER_CODE_SET;
	alias STORAGE_IDENTIFIER_CODE_SET* PSTORAGE_IDENTIFIER_CODE_SET;

	enum {
		StorageIdTypeVendorSpecific = 0,
		StorageIdTypeVendorId = 1,
		StorageIdTypeEUI64 = 2,
		StorageIdTypeFCPHName = 3,
		StorageIdTypePortRelative = 4,
		StorageIdTypeTargetPortGroup = 5,
		StorageIdTypeLogicalUnitGroup = 6,
		StorageIdTypeMD5LogicalUnitIdentifier = 7,
		StorageIdTypeScsiNameString = 8
	}
	alias int STORAGE_IDENTIFIER_TYPE;
	alias STORAGE_IDENTIFIER_TYPE* PSTORAGE_IDENTIFIER_TYPE;

	alias StorageIdTypeFCPHName StorageIdTypeNAA;

	enum {
		StorageIdNAAFormatIEEEExtended = 2,
		StorageIdNAAFormatIEEERegistered = 3,
		StorageIdNAAFormatIEEEERegisteredExtended = 5
	}
	alias int STORAGE_ID_NAA_FORMAT;
	alias STORAGE_ID_NAA_FORMAT* PSTORAGE_ID_NAA_FORMAT;

	enum {
		StorageIdAssocDevice = 0,
		StorageIdAssocPort = 1,
		StorageIdAssocTarget = 2
	}
	alias int STORAGE_ASSOCIATION_TYPE;
	alias STORAGE_ASSOCIATION_TYPE* PSTORAGE_ASSOCIATION_TYPE;

	struct STORAGE_IDENTIFIER {
		STORAGE_IDENTIFIER_CODE_SET CodeSet;
		STORAGE_IDENTIFIER_TYPE Type;
		WORD IdentifierSize;
		WORD NextOffset;
		STORAGE_ASSOCIATION_TYPE Association;
		BYTE[1] Identifier;
	}
	alias STORAGE_IDENTIFIER* PSTORAGE_IDENTIFIER;

	struct STORAGE_DEVICE_ID_DESCRIPTOR {
		DWORD Version;
		DWORD Size;
		DWORD NumberOfIdentifiers;
		BYTE[1] Identifiers;
	}
	alias STORAGE_DEVICE_ID_DESCRIPTOR* PSTORAGE_DEVICE_ID_DESCRIPTOR;

	struct DEVICE_SEEK_PENALTY_DESCRIPTOR {
		DWORD Version;
		DWORD Size;
		BOOLEAN IncursSeekPenalty;
	}
	alias DEVICE_SEEK_PENALTY_DESCRIPTOR* PDEVICE_SEEK_PENALTY_DESCRIPTOR;

	struct DEVICE_WRITE_AGGREGATION_DESCRIPTOR {
		DWORD Version;
		DWORD Size;
		BOOLEAN BenefitsFromWriteAggregation;
	}
	alias DEVICE_WRITE_AGGREGATION_DESCRIPTOR* PDEVICE_WRITE_AGGREGATION_DESCRIPTOR;

	struct DEVICE_TRIM_DESCRIPTOR {
		DWORD Version;
		DWORD Size;
		BOOLEAN TrimEnabled;
	}
	alias DEVICE_TRIM_DESCRIPTOR* PDEVICE_TRIM_DESCRIPTOR;

	enum DeviceDsmActionFlag_NonDestructive = 0x80000000;

	/*BOOLEAN IsDsmActionNonDestructive(_Action)
	{
		return ((BOOLEAN)((_Action & DeviceDsmActionFlag_NonDestructive) != 0))
	}*/

	alias DWORD DEVICE_DATA_MANAGEMENT_SET_ACTION;
	enum {
		DeviceDsmAction_None = 0,
		DeviceDsmAction_Trim = 1,
		DeviceDsmAction_Notification = 2 | DeviceDsmActionFlag_NonDestructive,
	}
	
	enum DEVICE_DSM_FLAG_ENTIRE_DATA_SET_RANGE = 0x00000001;

	struct DEVICE_DATA_SET_RANGE {
		LONGLONG StartingOffset;
		DWORDLONG LengthInBytes;
	}
	alias DEVICE_DATA_SET_RANGE* PDEVICE_DATA_SET_RANGE;

	struct DEVICE_MANAGE_DATA_SET_ATTRIBUTES {
		DWORD Size;
		DEVICE_DATA_MANAGEMENT_SET_ACTION Action;
		DWORD Flags;
		DWORD ParameterBlockOffset;
		DWORD ParameterBlockLength;
		DWORD DataSetRangesOffset;
		DWORD DataSetRangesLength;
	}
	alias DEVICE_MANAGE_DATA_SET_ATTRIBUTES* PDEVICE_MANAGE_DATA_SET_ATTRIBUTES;

	struct DEVICE_DSM_NOTIFICATION_PARAMETERS {
		DWORD Size;
		DWORD Flags;
		DWORD NumFileTypeIDs;
		GUID[1] FileTypeID;
	}
	alias DEVICE_DSM_NOTIFICATION_PARAMETERS* PDEVICE_DSM_NOTIFICATION_PARAMETERS;

	enum {
		DEVICE_DSM_NOTIFY_FLAG_BEGIN = 0x00000001,
		DEVICE_DSM_NOTIFY_FLAG_END = 0x00000002,
	}

	struct STORAGE_GET_BC_PROPERTIES_OUTPUT {
		DWORD MaximumRequestsPerPeriod;
		DWORD MinimumPeriod;
		DWORDLONG MaximumRequestSize;
		DWORD EstimatedTimePerRequest;
		DWORD NumOutStandingRequests;
		DWORDLONG RequestSize;
	}
	alias STORAGE_GET_BC_PROPERTIES_OUTPUT* PSTORAGE_GET_BC_PROPERTIES_OUTPUT;

	enum IOCTL_STORAGE_BC_VERSION = 1;

	struct STORAGE_ALLOCATE_BC_STREAM_INPUT {
		DWORD Version;
		DWORD RequestsPerPeriod;
		DWORD Period;
		BOOLEAN RetryFailures;
		BOOLEAN Discardable;
		BOOLEAN[2] Reserved1;
		DWORD AccessType;
		DWORD AccessMode;
	}
	alias STORAGE_ALLOCATE_BC_STREAM_INPUT* PSTORAGE_ALLOCATE_BC_STREAM_INPUT;

	struct STORAGE_ALLOCATE_BC_STREAM_OUTPUT {
		DWORDLONG RequestSize;
		DWORD NumOutStandingRequests;
	}
	alias STORAGE_ALLOCATE_BC_STREAM_OUTPUT* PSTORAGE_ALLOCATE_BC_STREAM_OUTPUT;

	enum STORAGE_PRIORITY_HINT_SUPPORTED = 0x0001;

	struct STORAGE_PRIORITY_HINT_SUPPORT {
		DWORD SupportFlags;
	}
	alias STORAGE_PRIORITY_HINT_SUPPORT* PSTORAGE_PRIORITY_HINT_SUPPORT;


	//_MSC_EXTENSIONS
		struct STORAGE_MEDIA_SERIAL_NUMBER_DATA {
			WORD Reserved;
			WORD SerialNumberLength;
			BYTE[0] SerialNumber;
		}
		alias STORAGE_MEDIA_SERIAL_NUMBER_DATA* PSTORAGE_MEDIA_SERIAL_NUMBER_DATA;

	struct STORAGE_READ_CAPACITY {
		DWORD Version;
		DWORD Size;
		DWORD BlockLength;
		LARGE_INTEGER NumberOfBlocks;
		LARGE_INTEGER DiskLength;
	}
	alias STORAGE_READ_CAPACITY* PSTORAGE_READ_CAPACITY;

	enum {
		WriteCacheTypeUnknown,
		WriteCacheTypeNone,
		WriteCacheTypeWriteBack,
		WriteCacheTypeWriteThrough
	}
	alias int WRITE_CACHE_TYPE;

	enum {
		WriteCacheEnableUnknown,
		WriteCacheDisabled,
		WriteCacheEnabled
	}
	alias int WRITE_CACHE_ENABLE;

	enum {
		WriteCacheChangeUnknown,
		WriteCacheNotChangeable,
		WriteCacheChangeable
	}
	alias int WRITE_CACHE_CHANGE;

	enum {
		WriteThroughUnknown,
		WriteThroughNotSupported,
		WriteThroughSupported
	}
	alias int WRITE_THROUGH;

	struct STORAGE_WRITE_CACHE_PROPERTY {
		DWORD Version;
		DWORD Size;
		WRITE_CACHE_TYPE WriteCacheType;
		WRITE_CACHE_ENABLE WriteCacheEnabled;
		WRITE_CACHE_CHANGE WriteCacheChangeable;
		WRITE_THROUGH WriteThroughSupported;
		BOOLEAN FlushCacheSupported;
		BOOLEAN UserDefinedPowerProtection;
		BOOLEAN NVCacheEnabled;
	}
	alias STORAGE_WRITE_CACHE_PROPERTY* PSTORAGE_WRITE_CACHE_PROPERTY;

	//_MSC_EXTENSIONS
		/*struct PERSISTENT_RESERVE_COMMAND {
			DWORD Version;
			DWORD Size;
			union {
				struct {
					BYTE ServiceAction : 5;
					BYTE Reserved1 : 3;
					WORD AllocationLength;
				}// PR_IN;
				struct {
					BYTE ServiceAction : 5;
					BYTE Reserved1 : 3;
					BYTE Type : 4;
					BYTE Scope : 4;
					BYTE ParameterList[0];
				}// PR_OUT;
			}
		}
		alias PERSISTENT_RESERVE_COMMAND* PPERSISTENT_RESERVE_COMMAND;*/
	}// extern(C)
}

version(all){//_NTDDDISK_H_

	enum {
		IOCTL_DISK_BASE                = FILE_DEVICE_DISK,
		IOCTL_DISK_GET_DRIVE_GEOMETRY  = CTL_CODE(IOCTL_DISK_BASE, 0x0000, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_DISK_GET_PARTITION_INFO  = CTL_CODE(IOCTL_DISK_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_DISK_SET_PARTITION_INFO  = CTL_CODE(IOCTL_DISK_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
		IOCTL_DISK_GET_DRIVE_LAYOUT    = CTL_CODE(IOCTL_DISK_BASE, 0x0003, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_DISK_SET_DRIVE_LAYOUT    = CTL_CODE(IOCTL_DISK_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
		IOCTL_DISK_VERIFY              = CTL_CODE(IOCTL_DISK_BASE, 0x0005, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_DISK_FORMAT_TRACKS       = CTL_CODE(IOCTL_DISK_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
		IOCTL_DISK_REASSIGN_BLOCKS     = CTL_CODE(IOCTL_DISK_BASE, 0x0007, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
		IOCTL_DISK_PERFORMANCE         = CTL_CODE(IOCTL_DISK_BASE, 0x0008, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_DISK_IS_WRITABLE         = CTL_CODE(IOCTL_DISK_BASE, 0x0009, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_DISK_LOGGING             = CTL_CODE(IOCTL_DISK_BASE, 0x000a, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_DISK_FORMAT_TRACKS_EX    = CTL_CODE(IOCTL_DISK_BASE, 0x000b, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
		IOCTL_DISK_HISTOGRAM_STRUCTURE = CTL_CODE(IOCTL_DISK_BASE, 0x000c, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_DISK_HISTOGRAM_DATA      = CTL_CODE(IOCTL_DISK_BASE, 0x000d, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_DISK_HISTOGRAM_RESET     = CTL_CODE(IOCTL_DISK_BASE, 0x000e, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_DISK_REQUEST_STRUCTURE   = CTL_CODE(IOCTL_DISK_BASE, 0x000f, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_DISK_REQUEST_DATA        = CTL_CODE(IOCTL_DISK_BASE, 0x0010, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_DISK_PERFORMANCE_OFF     = CTL_CODE(IOCTL_DISK_BASE, 0x0018, METHOD_BUFFERED, FILE_ANY_ACCESS),

		IOCTL_DISK_CONTROLLER_NUMBER = CTL_CODE(IOCTL_DISK_BASE, 0x0011, METHOD_BUFFERED, FILE_ANY_ACCESS),

		SMART_GET_VERSION        = CTL_CODE(IOCTL_DISK_BASE, 0x0020, METHOD_BUFFERED, FILE_READ_ACCESS),
		SMART_SEND_DRIVE_COMMAND = CTL_CODE(IOCTL_DISK_BASE, 0x0021, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
		SMART_RCV_DRIVE_DATA     = CTL_CODE(IOCTL_DISK_BASE, 0x0022, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),

		IOCTL_DISK_GET_PARTITION_INFO_EX = CTL_CODE(IOCTL_DISK_BASE, 0x0012, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_DISK_SET_PARTITION_INFO_EX = CTL_CODE(IOCTL_DISK_BASE, 0x0013, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
		IOCTL_DISK_GET_DRIVE_LAYOUT_EX   = CTL_CODE(IOCTL_DISK_BASE, 0x0014, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_DISK_SET_DRIVE_LAYOUT_EX   = CTL_CODE(IOCTL_DISK_BASE, 0x0015, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
		IOCTL_DISK_CREATE_DISK           = CTL_CODE(IOCTL_DISK_BASE, 0x0016, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
		IOCTL_DISK_GET_LENGTH_INFO       = CTL_CODE(IOCTL_DISK_BASE, 0x0017, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_DISK_GET_DRIVE_GEOMETRY_EX = CTL_CODE(IOCTL_DISK_BASE, 0x0028, METHOD_BUFFERED, FILE_ANY_ACCESS),

	//(_WIN32_WINNT >= 0x0502)
			IOCTL_DISK_REASSIGN_BLOCKS_EX = CTL_CODE(IOCTL_DISK_BASE, 0x0029, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),

		IOCTL_DISK_UPDATE_DRIVE_SIZE = CTL_CODE(IOCTL_DISK_BASE, 0x0032, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
		IOCTL_DISK_GROW_PARTITION    = CTL_CODE(IOCTL_DISK_BASE, 0x0034, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),

		IOCTL_DISK_GET_CACHE_INFORMATION = CTL_CODE(IOCTL_DISK_BASE, 0x0035, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_DISK_SET_CACHE_INFORMATION = CTL_CODE(IOCTL_DISK_BASE, 0x0036, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
	//(NTDDI_VERSION < NTDDI_WIN2003)
		//	IOCTL_DISK_GET_WRITE_CACHE_STATE CTL_CODE(IOCTL_DISK_BASE, 0x0037, METHOD_BUFFERED, FILE_READ_ACCESS)
	//else
			OBSOLETE_DISK_GET_WRITE_CACHE_STATE = CTL_CODE(IOCTL_DISK_BASE, 0x0037, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_DISK_DELETE_DRIVE_LAYOUT = CTL_CODE(IOCTL_DISK_BASE, 0x0040, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
		IOCTL_DISK_UPDATE_PROPERTIES   = CTL_CODE(IOCTL_DISK_BASE, 0x0050, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_DISK_FORMAT_DRIVE        = CTL_CODE(IOCTL_DISK_BASE, 0x00f3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
		IOCTL_DISK_SENSE_DEVICE        = CTL_CODE(IOCTL_DISK_BASE, 0x00f8, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_DISK_CHECK_VERIFY        = CTL_CODE(IOCTL_DISK_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_DISK_MEDIA_REMOVAL       = CTL_CODE(IOCTL_DISK_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_DISK_EJECT_MEDIA         = CTL_CODE(IOCTL_DISK_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_DISK_LOAD_MEDIA          = CTL_CODE(IOCTL_DISK_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_DISK_RESERVE             = CTL_CODE(IOCTL_DISK_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_DISK_RELEASE             = CTL_CODE(IOCTL_DISK_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_DISK_FIND_NEW_DEVICES    = CTL_CODE(IOCTL_DISK_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS),
		IOCTL_DISK_GET_MEDIA_TYPES     = CTL_CODE(IOCTL_DISK_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS),
	}

	enum {
		PARTITION_ENTRY_UNUSED    = 0x00,
		PARTITION_FAT_12          = 0x01,
		PARTITION_XENIX_1         = 0x02,
		PARTITION_XENIX_2         = 0x03,
		PARTITION_FAT_16          = 0x04,
		PARTITION_EXTENDED        = 0x05,
		PARTITION_HUGE            = 0x06,
		PARTITION_IFS             = 0x07,
		PARTITION_OS2BOOTMGR      = 0x0A,
		PARTITION_FAT32           = 0x0B,
		PARTITION_FAT32_XINT13    = 0x0C,
		PARTITION_XINT13          = 0x0E,
		PARTITION_XINT13_EXTENDED = 0x0F,
		PARTITION_PREP            = 0x41,
		PARTITION_LDM             = 0x42,
		PARTITION_UNIX            = 0x63,
		VALID_NTFT                = 0xC0,
		PARTITION_NTFT            = 0x80,
	}

	//(NTDDK_VERSION < NTDDI_VISTA)
//			IsRecognizedPartition( PartitionType ) (  ((PartitionType & PARTITION_NTFT) && (((PartitionType & ~0xC0) == PARTITION_HUGE) ||  ((PartitionType & ~0xC0) == PARTITION_IFS) ||  ((PartitionType & ~0xC0) == PARTITION_FAT32) ||  ((PartitionType & ~0xC0) == PARTITION_FAT32_XINT13))) ||  ((PartitionType) == PARTITION_FAT_12) ||  ((PartitionType) == PARTITION_FAT_16) ||  ((PartitionType) == PARTITION_HUGE) ||  ((PartitionType) == PARTITION_IFS) ||  ((PartitionType) == PARTITION_FAT32) ||  ((PartitionType) == PARTITION_FAT32_XINT13) ||  ((PartitionType) == PARTITION_XINT13) )
	//else
//			IsRecognizedPartition( PartitionType ) (  ((PartitionType) == PARTITION_FAT_12) ||  ((PartitionType) == PARTITION_FAT_16) ||  ((PartitionType) == PARTITION_HUGE) ||  ((PartitionType) == PARTITION_IFS) ||  ((PartitionType) == PARTITION_FAT32) ||  ((PartitionType) == PARTITION_FAT32_XINT13) ||  ((PartitionType) == PARTITION_XINT13) )
//		IsContainerPartition( PartitionType )  ((PartitionType == PARTITION_EXTENDED) || (PartitionType == PARTITION_XINT13_EXTENDED))
//		IsFTPartition( PartitionType )  ((PartitionType & PARTITION_NTFT) && (((PartitionType & ~0xC0) == PARTITION_HUGE) ||  ((PartitionType & ~0xC0) == PARTITION_IFS) ||  ((PartitionType & ~0xC0) == PARTITION_FAT32) ||  ((PartitionType & ~0xC0) == PARTITION_FAT32_XINT13)))

	enum {
		Unknown,
		F5_1Pt2_512,
		F3_1Pt44_512,
		F3_2Pt88_512,
		F3_20Pt8_512,
		F3_720_512,
		F5_360_512,
		F5_320_512,
		F5_320_1024,
		F5_180_512,
		F5_160_512,
		RemovableMedia,
		FixedMedia,
		F3_120M_512,
		F3_640_512,
		F5_640_512,
		F5_720_512,
		F3_1Pt2_512,
		F3_1Pt23_1024,
		F5_1Pt23_1024,
		F3_128Mb_512,
		F3_230Mb_512,
		F8_256_128,
		F3_200Mb_512,
		F3_240M_512,
		F3_32M_512
	}
	alias int MEDIA_TYPE;
	alias MEDIA_TYPE* PMEDIA_TYPE;

	struct FORMAT_PARAMETERS {
		MEDIA_TYPE MediaType;
		DWORD StartCylinderNumber;
		DWORD EndCylinderNumber;
		DWORD StartHeadNumber;
		DWORD EndHeadNumber;
	}
	alias FORMAT_PARAMETERS* PFORMAT_PARAMETERS;

	alias WORD BAD_TRACK_NUMBER;
	alias WORD* PBAD_TRACK_NUMBER;

	struct FORMAT_EX_PARAMETERS {
		MEDIA_TYPE MediaType;
		DWORD StartCylinderNumber;
		DWORD EndCylinderNumber;
		DWORD StartHeadNumber;
		DWORD EndHeadNumber;
		WORD FormatGapLength;
		WORD SectorsPerTrack;
		WORD[1] SectorNumber;
	}
	alias FORMAT_EX_PARAMETERS* PFORMAT_EX_PARAMETERS;

	struct DISK_GEOMETRY {
		LARGE_INTEGER Cylinders;
		MEDIA_TYPE MediaType;
		DWORD TracksPerCylinder;
		DWORD SectorsPerTrack;
		DWORD BytesPerSector;
	}
	alias DISK_GEOMETRY* PDISK_GEOMETRY;

	mixin DEFINE_GUID!("WMI_DISK_GEOMETRY_GUID", 0x25007f51, 0x57c2, 0x11d1, 0xa5, 0x28, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);

	struct PARTITION_INFORMATION {
		LARGE_INTEGER StartingOffset;
		LARGE_INTEGER PartitionLength;
		DWORD HiddenSectors;
		DWORD PartitionNumber;
		BYTE PartitionType;
		BOOLEAN BootIndicator;
		BOOLEAN RecognizedPartition;
		BOOLEAN RewritePartition;
	}
	alias PARTITION_INFORMATION* PPARTITION_INFORMATION;

	struct SET_PARTITION_INFORMATION {
		BYTE PartitionType;
	}
	alias SET_PARTITION_INFORMATION* PSET_PARTITION_INFORMATION;

	struct DRIVE_LAYOUT_INFORMATION {
		DWORD PartitionCount;
		DWORD Signature;
		PARTITION_INFORMATION[1] PartitionEntry;
	}
	alias DRIVE_LAYOUT_INFORMATION* PDRIVE_LAYOUT_INFORMATION;

	struct VERIFY_INFORMATION {
		LARGE_INTEGER StartingOffset;
		DWORD Length;
	}
	alias VERIFY_INFORMATION* PVERIFY_INFORMATION;

	struct REASSIGN_BLOCKS {
		WORD Reserved;
		WORD Count;
		DWORD[1] BlockNumber;
	}
	alias REASSIGN_BLOCKS* PREASSIGN_BLOCKS;

	align(1)
	struct REASSIGN_BLOCKS_EX {
		WORD Reserved;
		WORD Count;
		LARGE_INTEGER[1] BlockNumber;
	}
	alias REASSIGN_BLOCKS_EX* PREASSIGN_BLOCKS_EX;

	enum {
		PARTITION_STYLE_MBR,
		PARTITION_STYLE_GPT,
		PARTITION_STYLE_RAW
	}
	alias int PARTITION_STYLE;

	struct PARTITION_INFORMATION_GPT {
		GUID PartitionType;
		GUID PartitionId;
		DWORD64 Attributes;
		WCHAR Name [36];
	}
	alias PARTITION_INFORMATION_GPT* PPARTITION_INFORMATION_GPT;

	enum {
		GPT_ATTRIBUTE_PLATFORM_REQUIRED          = 0x0000000000000001,
		GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER = 0x8000000000000000,
		GPT_BASIC_DATA_ATTRIBUTE_HIDDEN          = 0x4000000000000000,
		GPT_BASIC_DATA_ATTRIBUTE_SHADOW_COPY     = 0x2000000000000000,
		GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY       = 0x1000000000000000,
	}

	struct PARTITION_INFORMATION_MBR {
		BYTE PartitionType;
		BOOLEAN BootIndicator;
		BOOLEAN RecognizedPartition;
		DWORD HiddenSectors;
	}
	alias PARTITION_INFORMATION_MBR* PPARTITION_INFORMATION_MBR;

	alias SET_PARTITION_INFORMATION SET_PARTITION_INFORMATION_MBR;
	alias PARTITION_INFORMATION_GPT SET_PARTITION_INFORMATION_GPT;

	struct SET_PARTITION_INFORMATION_EX {
		PARTITION_STYLE PartitionStyle;
		union {
			SET_PARTITION_INFORMATION_MBR Mbr;
			SET_PARTITION_INFORMATION_GPT Gpt;
		}
	}
	alias SET_PARTITION_INFORMATION_EX* PSET_PARTITION_INFORMATION_EX;

	struct CREATE_DISK_GPT {
		GUID DiskId;
		DWORD MaxPartitionCount;
	}
	alias CREATE_DISK_GPT* PCREATE_DISK_GPT;

	struct CREATE_DISK_MBR {
		DWORD Signature;
	}
	alias CREATE_DISK_MBR* PCREATE_DISK_MBR;

	struct CREATE_DISK {
		PARTITION_STYLE PartitionStyle;
		union {
			CREATE_DISK_MBR Mbr;
			CREATE_DISK_GPT Gpt;
		}
	}
	alias CREATE_DISK* PCREATE_DISK;

	struct GET_LENGTH_INFORMATION {
		LARGE_INTEGER Length;
	}
	alias GET_LENGTH_INFORMATION* PGET_LENGTH_INFORMATION;

	struct PARTITION_INFORMATION_EX {
		PARTITION_STYLE PartitionStyle;
		LARGE_INTEGER StartingOffset;
		LARGE_INTEGER PartitionLength;
		DWORD PartitionNumber;
		BOOLEAN RewritePartition;
		union {
			PARTITION_INFORMATION_MBR Mbr;
			PARTITION_INFORMATION_GPT Gpt;
		}
	}
	alias PARTITION_INFORMATION_EX* PPARTITION_INFORMATION_EX;

	struct DRIVE_LAYOUT_INFORMATION_GPT {
		GUID DiskId;
		LARGE_INTEGER StartingUsableOffset;
		LARGE_INTEGER UsableLength;
		DWORD MaxPartitionCount;
	}
	alias DRIVE_LAYOUT_INFORMATION_GPT* PDRIVE_LAYOUT_INFORMATION_GPT;

	struct DRIVE_LAYOUT_INFORMATION_MBR {
		DWORD Signature;
	}
	alias DRIVE_LAYOUT_INFORMATION_MBR* PDRIVE_LAYOUT_INFORMATION_MBR;

	struct DRIVE_LAYOUT_INFORMATION_EX {
		DWORD PartitionStyle;
		DWORD PartitionCount;
		union {
			DRIVE_LAYOUT_INFORMATION_MBR Mbr;
			DRIVE_LAYOUT_INFORMATION_GPT Gpt;
		}
		PARTITION_INFORMATION_EX[1] PartitionEntry;
	}
	alias DRIVE_LAYOUT_INFORMATION_EX* PDRIVE_LAYOUT_INFORMATION_EX;

	enum {
		DetectNone,
		DetectInt13,
		DetectExInt13
	}
	alias int DETECTION_TYPE;

	struct DISK_INT13_INFO {
		WORD DriveSelect;
		DWORD MaxCylinders;
		WORD SectorsPerTrack;
		WORD MaxHeads;
		WORD NumberDrives;
	}
	alias DISK_INT13_INFO* PDISK_INT13_INFO;

	struct DISK_EX_INT13_INFO {
		WORD ExBufferSize;
		WORD ExFlags;
		DWORD ExCylinders;
		DWORD ExHeads;
		DWORD ExSectorsPerTrack;
		DWORD64 ExSectorsPerDrive;
		WORD ExSectorSize;
		WORD ExReserved;
	}
	alias DISK_EX_INT13_INFO* PDISK_EX_INT13_INFO;

	struct DISK_DETECTION_INFO {
		DWORD SizeOfDetectInfo;
		DETECTION_TYPE DetectionType;
		union {
			struct {
				DISK_INT13_INFO Int13;
				DISK_EX_INT13_INFO ExInt13;
			}
		}
	}
	alias DISK_DETECTION_INFO* PDISK_DETECTION_INFO;

	struct DISK_PARTITION_INFO {
		DWORD SizeOfPartitionInfo;
		PARTITION_STYLE PartitionStyle;
		union {
			struct {
				DWORD Signature;
				DWORD CheckSum;
			}// Mbr;
			struct {
				GUID DiskId;
			}// Gpt;
		}
	}
	alias DISK_PARTITION_INFO* PDISK_PARTITION_INFO;

//	#if (NTDDI_VERSION < NTDDI_WIN2003)
//			DiskGeometryGetPartition(Geometry) ((PDISK_PARTITION_INFO)((Geometry)+1))
//			DiskGeometryGetDetect(Geometry) ((PDISK_DETECTION_INFO)(((PBYTE)DiskGeometryGetPartition(Geometry)+ DiskGeometryGetPartition(Geometry)->SizeOfPartitionInfo)))
//	#else
			//DiskGeometryGetPartition(Geometry) ((PDISK_PARTITION_INFO)((Geometry)->Data))
			//DiskGeometryGetDetect(Geometry) ((PDISK_DETECTION_INFO)(((DWORD_PTR)DiskGeometryGetPartition(Geometry)+ DiskGeometryGetPartition(Geometry)->SizeOfPartitionInfo)))

	struct DISK_GEOMETRY_EX {
		DISK_GEOMETRY Geometry;
		LARGE_INTEGER DiskSize;
		BYTE[1] Data;
	}
	alias DISK_GEOMETRY_EX* PDISK_GEOMETRY_EX;

	struct DISK_CONTROLLER_NUMBER {
		DWORD ControllerNumber;
		DWORD DiskNumber;
	}
	alias DISK_CONTROLLER_NUMBER* PDISK_CONTROLLER_NUMBER;

	enum {
		EqualPriority,
		KeepPrefetchedData,
		KeepReadData
	}
	alias int DISK_CACHE_RETENTION_PRIORITY;

	//(OSVER(NTDDI_VERSION) == NTDDI_WINXP)
	enum {
		DiskWriteCacheNormal,
		DiskWriteCacheForceDisable,
		DiskWriteCacheDisableNotSupported
	}
	alias int DISK_WRITE_CACHE_STATE;
	alias DISK_WRITE_CACHE_STATE* PDISK_WRITE_CACHE_STATE;

	struct DISK_CACHE_INFORMATION {
		BOOLEAN ParametersSavable;
		BOOLEAN ReadCacheEnabled;
		BOOLEAN WriteCacheEnabled;
		DISK_CACHE_RETENTION_PRIORITY ReadRetentionPriority;
		DISK_CACHE_RETENTION_PRIORITY WriteRetentionPriority;
		WORD DisablePrefetchTransferLength;
		BOOLEAN PrefetchScalar;

		union {
			struct ScalarPrefetch_ {
				WORD Minimum;
				WORD Maximum;
				WORD MaximumBlocks;
			}
			ScalarPrefetch_ ScalarPrefetch;
			struct BlockPrefetch_ {
				WORD Minimum;
				WORD Maximum;
			}
			BlockPrefetch_ BlockPrefetch;
		}
	}
	alias DISK_CACHE_INFORMATION* PDISK_CACHE_INFORMATION;

	struct DISK_GROW_PARTITION {
		DWORD PartitionNumber;
		LARGE_INTEGER BytesToGrow;
	}
	alias DISK_GROW_PARTITION* PDISK_GROW_PARTITION;

	enum HIST_NO_OF_BUCKETS = 24;

	struct HISTOGRAM_BUCKET {
		DWORD Reads;
		DWORD Writes;
	}
	alias HISTOGRAM_BUCKET* PHISTOGRAM_BUCKET;

	enum HISTOGRAM_BUCKET_SIZE = HISTOGRAM_BUCKET.sizeof;

	struct DISK_HISTOGRAM {
		LARGE_INTEGER DiskSize;
		LARGE_INTEGER Start;
		LARGE_INTEGER End;
		LARGE_INTEGER Average;
		LARGE_INTEGER AverageRead;
		LARGE_INTEGER AverageWrite;
		DWORD Granularity;
		DWORD Size;
		DWORD ReadCount;
		DWORD WriteCount;
		PHISTOGRAM_BUCKET Histogram;
	}
	alias DISK_HISTOGRAM* PDISK_HISTOGRAM;

	enum DISK_HISTOGRAM_SIZE = DISK_HISTOGRAM.sizeof;

	struct DISK_PERFORMANCE {
		LARGE_INTEGER BytesRead;
		LARGE_INTEGER BytesWritten;
		LARGE_INTEGER ReadTime;
		LARGE_INTEGER WriteTime;
		LARGE_INTEGER IdleTime;
		DWORD ReadCount;
		DWORD WriteCount;
		DWORD QueueDepth;
		DWORD SplitCount;
		LARGE_INTEGER QueryTime;
		DWORD StorageDeviceNumber;
		WCHAR[8] StorageManagerName;
	}
	alias DISK_PERFORMANCE* PDISK_PERFORMANCE;

	struct DISK_RECORD {
		LARGE_INTEGER ByteOffset;
		LARGE_INTEGER StartTime;
		LARGE_INTEGER EndTime;
		PVOID VirtualAddress;
		DWORD NumberOfBytes;
		BYTE DeviceNumber;
		BOOLEAN ReadRequest;
	}
	alias DISK_RECORD* PDISK_RECORD;

	struct DISK_LOGGING {
		BYTE Function;
		PVOID BufferAddress;
		DWORD BufferSize;
	}
	alias DISK_LOGGING* PDISK_LOGGING;

	enum {
		DISK_LOGGING_START = 0,
		DISK_LOGGING_STOP  = 1,
		DISK_LOGGING_DUMP  = 2,
		DISK_BINNING       = 3,
	}

	enum {
		RequestSize,
		RequestLocation
	}
	alias int BIN_TYPES;

	struct BIN_RANGE {
		LARGE_INTEGER StartValue;
		LARGE_INTEGER Length;
	}
	alias BIN_RANGE* PBIN_RANGE;

	struct PERF_BIN {
		DWORD NumberOfBins;
		DWORD TypeOfBin;
		BIN_RANGE[1] BinsRanges;
	}
	alias PERF_BIN* PPERF_BIN;

	struct BIN_COUNT {
		BIN_RANGE BinRange;
		DWORD BinCount;
	}
	alias BIN_COUNT* PBIN_COUNT;

	struct BIN_RESULTS {
		DWORD NumberOfBins;
		BIN_COUNT[1] BinCounts;
	}
	alias BIN_RESULTS* PBIN_RESULTS;

	align(1)
	struct GETVERSIONINPARAMS {
		BYTE bVersion;
		BYTE bRevision;
		BYTE bReserved;
		BYTE bIDEDeviceMap;
		DWORD fCapabilities;
		DWORD[4] dwReserved;
	}
	alias GETVERSIONINPARAMS* PGETVERSIONINPARAMS;
	alias GETVERSIONINPARAMS* LPGETVERSIONINPARAMS;

	enum {
		CAP_ATA_ID_CMD   = 1,
		CAP_ATAPI_ID_CMD = 2,
		CAP_SMART_CMD    = 4,
	}

	align(1)
	struct IDEREGS {
		BYTE bFeaturesReg;
		BYTE bSectorCountReg;
		BYTE bSectorNumberReg;
		BYTE bCylLowReg;
		BYTE bCylHighReg;
		BYTE bDriveHeadReg;
		BYTE bCommandReg;
		BYTE bReserved;
	}
	alias IDEREGS* PIDEREGS;
	alias IDEREGS* LPIDEREGS;

	enum {
		ATAPI_ID_CMD  = 0xA1,
		ID_CMD        = 0xEC,
		SMART_CMD     = 0xB0,
		SMART_CYL_LOW = 0x4F,
		SMART_CYL_HI  = 0xC2,
	}

	align(1)
	struct SENDCMDINPARAMS {
		DWORD cBufferSize;
		IDEREGS irDriveRegs;
		BYTE bDriveNumber;
		BYTE[3] bReserved;
		DWORD[4] dwReserved;
		BYTE[1] bBuffer;
	}
	alias SENDCMDINPARAMS* PSENDCMDINPARAMS;
	alias SENDCMDINPARAMS* LPSENDCMDINPARAMS;

	align(1)
	struct DRIVERSTATUS {
		BYTE bDriverError;
		BYTE bIDEError;
		BYTE[2] bReserved;
		DWORD[2] dwReserved;
	}
	alias DRIVERSTATUS* PDRIVERSTATUS;
	alias DRIVERSTATUS* LPDRIVERSTATUS;

	enum {
		SMART_NO_ERROR                  = 0,
		SMART_IDE_ERROR                 = 1,
		SMART_INVALID_FLAG              = 2,
		SMART_INVALID_COMMAND           = 3,
		SMART_INVALID_BUFFER            = 4,
		SMART_INVALID_DRIVE             = 5,
		SMART_INVALID_IOCTL             = 6,
		SMART_ERROR_NO_MEM              = 7,
		SMART_INVALID_REGISTER          = 8,
		SMART_NOT_SUPPORTED             = 9,
		SMART_NO_IDE_DEVICE             = 10,
		SMART_OFFLINE_ROUTINE_OFFLINE   = 0,
		SMART_SHORT_SELFTEST_OFFLINE    = 1,
		SMART_EXTENDED_SELFTEST_OFFLINE = 2,
		SMART_ABORT_OFFLINE_SELFTEST    = 127,
		SMART_SHORT_SELFTEST_CAPTIVE    = 129,
		SMART_EXTENDED_SELFTEST_CAPTIVE = 130,
	}

	align(1)
	struct SENDCMDOUTPARAMS {
		DWORD cBufferSize;
		DRIVERSTATUS DriverStatus;
		BYTE[1] bBuffer;
	}
	alias SENDCMDOUTPARAMS* PSENDCMDOUTPARAMS;
	alias SENDCMDOUTPARAMS* LPSENDCMDOUTPARAMS;

	enum {
		READ_ATTRIBUTE_BUFFER_SIZE = 512,
		IDENTIFY_BUFFER_SIZE       = 512,
		READ_THRESHOLD_BUFFER_SIZE = 512,
		SMART_LOG_SECTOR_SIZE      = 512,
	}

	enum {
		READ_ATTRIBUTES             = 0xD0,
		READ_THRESHOLDS             = 0xD1,
		ENABLE_DISABLE_AUTOSAVE     = 0xD2,
		SAVE_ATTRIBUTE_VALUES       = 0xD3,
		EXECUTE_OFFLINE_DIAGS       = 0xD4,
		SMART_READ_LOG              = 0xD5,
		SMART_WRITE_LOG             = 0xd6,
		ENABLE_SMART                = 0xD8,
		DISABLE_SMART               = 0xD9,
		RETURN_SMART_STATUS         = 0xDA,
		ENABLE_DISABLE_AUTO_OFFLINE = 0xDB,
	}

	enum IOCTL_DISK_RESET_SNAPSHOT_INFO = CTL_CODE(IOCTL_DISK_BASE, 0x0084, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);

}

enum {
	IOCTL_CHANGER_BASE                      = FILE_DEVICE_CHANGER,
	IOCTL_CHANGER_GET_PARAMETERS            = CTL_CODE(IOCTL_CHANGER_BASE, 0x0000, METHOD_BUFFERED, FILE_READ_ACCESS),
	IOCTL_CHANGER_GET_STATUS                = CTL_CODE(IOCTL_CHANGER_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS),
	IOCTL_CHANGER_GET_PRODUCT_DATA          = CTL_CODE(IOCTL_CHANGER_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS),
	IOCTL_CHANGER_SET_ACCESS                = CTL_CODE(IOCTL_CHANGER_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
	IOCTL_CHANGER_GET_ELEMENT_STATUS        = CTL_CODE(IOCTL_CHANGER_BASE, 0x0005, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
	IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS = CTL_CODE(IOCTL_CHANGER_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS),
	IOCTL_CHANGER_SET_POSITION              = CTL_CODE(IOCTL_CHANGER_BASE, 0x0007, METHOD_BUFFERED, FILE_READ_ACCESS),
	IOCTL_CHANGER_EXCHANGE_MEDIUM           = CTL_CODE(IOCTL_CHANGER_BASE, 0x0008, METHOD_BUFFERED, FILE_READ_ACCESS),
	IOCTL_CHANGER_MOVE_MEDIUM               = CTL_CODE(IOCTL_CHANGER_BASE, 0x0009, METHOD_BUFFERED, FILE_READ_ACCESS),
	IOCTL_CHANGER_REINITIALIZE_TRANSPORT    = CTL_CODE(IOCTL_CHANGER_BASE, 0x000A, METHOD_BUFFERED, FILE_READ_ACCESS),
	IOCTL_CHANGER_QUERY_VOLUME_TAGS         = CTL_CODE(IOCTL_CHANGER_BASE, 0x000B, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
}

enum {
	MAX_VOLUME_ID_SIZE       = 36,
	MAX_VOLUME_TEMPLATE_SIZE = 40,
}
enum {
	VENDOR_ID_LENGTH     = 8,
	PRODUCT_ID_LENGTH    = 16,
	REVISION_LENGTH      = 4,
	SERIAL_NUMBER_LENGTH = 32,
}

enum {
	AllElements,
	ChangerTransport,
	ChangerSlot,
	ChangerIEPort,
	ChangerDrive,
	ChangerDoor,
	ChangerKeypad,
	ChangerMaxElement
}
alias int ELEMENT_TYPE;
alias ELEMENT_TYPE* PELEMENT_TYPE;

struct CHANGER_ELEMENT {
	ELEMENT_TYPE ElementType;
	DWORD ElementAddress;
}
alias CHANGER_ELEMENT* PCHANGER_ELEMENT;

struct CHANGER_ELEMENT_LIST {
	CHANGER_ELEMENT Element;
	DWORD NumberOfElements;
}
alias CHANGER_ELEMENT_LIST* PCHANGER_ELEMENT_LIST;

enum {
	CHANGER_BAR_CODE_SCANNER_INSTALLED  = 0x00000001,
	CHANGER_INIT_ELEM_STAT_WITH_RANGE   = 0x00000002,
	CHANGER_CLOSE_IEPORT                = 0x00000004,
	CHANGER_OPEN_IEPORT                 = 0x00000008,
	CHANGER_STATUS_NON_VOLATILE         = 0x00000010,
	CHANGER_EXCHANGE_MEDIA              = 0x00000020,
	CHANGER_CLEANER_SLOT                = 0x00000040,
	CHANGER_LOCK_UNLOCK                 = 0x00000080,
	CHANGER_CARTRIDGE_MAGAZINE          = 0x00000100,
	CHANGER_MEDIUM_FLIP                 = 0x00000200,
	CHANGER_POSITION_TO_ELEMENT         = 0x00000400,
	CHANGER_REPORT_IEPORT_STATE         = 0x00000800,
	CHANGER_STORAGE_DRIVE               = 0x00001000,
	CHANGER_STORAGE_IEPORT              = 0x00002000,
	CHANGER_STORAGE_SLOT                = 0x00004000,
	CHANGER_STORAGE_TRANSPORT           = 0x00008000,
	CHANGER_DRIVE_CLEANING_REQUIRED     = 0x00010000,
	CHANGER_PREDISMOUNT_EJECT_REQUIRED  = 0x00020000,
	CHANGER_CLEANER_ACCESS_NOT_VALID    = 0x00040000,
	CHANGER_PREMOUNT_EJECT_REQUIRED     = 0x00080000,
	CHANGER_VOLUME_IDENTIFICATION       = 0x00100000,
	CHANGER_VOLUME_SEARCH               = 0x00200000,
	CHANGER_VOLUME_ASSERT               = 0x00400000,
	CHANGER_VOLUME_REPLACE              = 0x00800000,
	CHANGER_VOLUME_UNDEFINE             = 0x01000000,
	CHANGER_SERIAL_NUMBER_VALID         = 0x04000000,
	CHANGER_DEVICE_REINITIALIZE_CAPABLE = 0x08000000,
	CHANGER_KEYPAD_ENABLE_DISABLE       = 0x10000000,
	CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS  = 0x20000000,
	CHANGER_RESERVED_BIT                = 0x80000000,
	CHANGER_PREDISMOUNT_ALIGN_TO_SLOT   = 0x80000001,
	CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE  = 0x80000002,
	CHANGER_CLEANER_AUTODISMOUNT        = 0x80000004,
	CHANGER_TRUE_EXCHANGE_CAPABLE       = 0x80000008,
	CHANGER_SLOTS_USE_TRAYS             = 0x80000010,
	CHANGER_RTN_MEDIA_TO_ORIGINAL_ADDR  = 0x80000020,
	CHANGER_CLEANER_OPS_NOT_SUPPORTED   = 0x80000040,
	CHANGER_IEPORT_USER_CONTROL_OPEN    = 0x80000080,
	CHANGER_IEPORT_USER_CONTROL_CLOSE   = 0x80000100,
	CHANGER_MOVE_EXTENDS_IEPORT         = 0x80000200,
	CHANGER_MOVE_RETRACTS_IEPORT        = 0x80000400,
	CHANGER_TO_TRANSPORT                = 0x01,
	CHANGER_TO_SLOT                     = 0x02,
	CHANGER_TO_IEPORT                   = 0x04,
	CHANGER_TO_DRIVE                    = 0x08,
	LOCK_UNLOCK_IEPORT                  = 0x01,
	LOCK_UNLOCK_DOOR                    = 0x02,
	LOCK_UNLOCK_KEYPAD                  = 0x04,
}

struct GET_CHANGER_PARAMETERS {
	DWORD Size;
	WORD NumberTransportElements;
	WORD NumberStorageElements;
	WORD NumberCleanerSlots;
	WORD NumberIEElements;
	WORD NumberDataTransferElements;
	WORD NumberOfDoors;
	WORD FirstSlotNumber;
	WORD FirstDriveNumber;
	WORD FirstTransportNumber;
	WORD FirstIEPortNumber;
	WORD FirstCleanerSlotAddress;
	WORD MagazineSize;
	DWORD DriveCleanTimeout;
	DWORD Features0;
	DWORD Features1;
	BYTE MoveFromTransport;
	BYTE MoveFromSlot;
	BYTE MoveFromIePort;
	BYTE MoveFromDrive;
	BYTE ExchangeFromTransport;
	BYTE ExchangeFromSlot;
	BYTE ExchangeFromIePort;
	BYTE ExchangeFromDrive;
	BYTE LockUnlockCapabilities;
	BYTE PositionCapabilities;
	BYTE[2] Reserved1;
	DWORD[2] Reserved2;
}
alias GET_CHANGER_PARAMETERS* PGET_CHANGER_PARAMETERS;

struct CHANGER_PRODUCT_DATA {
	BYTE[VENDOR_ID_LENGTH] VendorId;
	BYTE[PRODUCT_ID_LENGTH] ProductId;
	BYTE[REVISION_LENGTH] Revision;
	BYTE[SERIAL_NUMBER_LENGTH] SerialNumber;
	BYTE DeviceType;
}
alias CHANGER_PRODUCT_DATA* PCHANGER_PRODUCT_DATA;

enum {
	LOCK_ELEMENT   = 0,
	UNLOCK_ELEMENT = 1,
	EXTEND_IEPORT  = 2,
	RETRACT_IEPORT = 3,
}

struct CHANGER_SET_ACCESS {
	CHANGER_ELEMENT Element;
	DWORD Control;
}
alias CHANGER_SET_ACCESS* PCHANGER_SET_ACCESS;

struct CHANGER_READ_ELEMENT_STATUS {
	CHANGER_ELEMENT_LIST ElementList;
	BOOLEAN VolumeTagInfo;
}
alias CHANGER_READ_ELEMENT_STATUS* PCHANGER_READ_ELEMENT_STATUS;

struct CHANGER_ELEMENT_STATUS {
	CHANGER_ELEMENT Element;
	CHANGER_ELEMENT SrcElementAddress;
	DWORD Flags;
	DWORD ExceptionCode;
	BYTE TargetId;
	BYTE Lun;
	WORD Reserved;
	BYTE[MAX_VOLUME_ID_SIZE] PrimaryVolumeID;
	BYTE[MAX_VOLUME_ID_SIZE] AlternateVolumeID;
}
alias CHANGER_ELEMENT_STATUS* PCHANGER_ELEMENT_STATUS;

struct CHANGER_ELEMENT_STATUS_EX {
	CHANGER_ELEMENT Element;
	CHANGER_ELEMENT SrcElementAddress;
	DWORD Flags;
	DWORD ExceptionCode;
	BYTE TargetId;
	BYTE Lun;
	WORD Reserved;
	BYTE[MAX_VOLUME_ID_SIZE] PrimaryVolumeID;
	BYTE[MAX_VOLUME_ID_SIZE] AlternateVolumeID;
	BYTE[VENDOR_ID_LENGTH] VendorIdentification;
	BYTE[PRODUCT_ID_LENGTH] ProductIdentification;
	BYTE[SERIAL_NUMBER_LENGTH] SerialNumber;
}
alias CHANGER_ELEMENT_STATUS_EX* PCHANGER_ELEMENT_STATUS_EX;

enum {
	ELEMENT_STATUS_FULL         = 0x00000001,
	ELEMENT_STATUS_IMPEXP       = 0x00000002,
	ELEMENT_STATUS_EXCEPT       = 0x00000004,
	ELEMENT_STATUS_ACCESS       = 0x00000008,
	ELEMENT_STATUS_EXENAB       = 0x00000010,
	ELEMENT_STATUS_INENAB       = 0x00000020,
	ELEMENT_STATUS_PRODUCT_DATA = 0x00000040,
	ELEMENT_STATUS_LUN_VALID    = 0x00001000,
	ELEMENT_STATUS_ID_VALID     = 0x00002000,
	ELEMENT_STATUS_NOT_BUS      = 0x00008000,
	ELEMENT_STATUS_INVERT       = 0x00400000,
	ELEMENT_STATUS_SVALID       = 0x00800000,
	ELEMENT_STATUS_PVOLTAG      = 0x10000000,
	ELEMENT_STATUS_AVOLTAG      = 0x20000000,
	ERROR_LABEL_UNREADABLE      = 0x00000001,
	ERROR_LABEL_QUESTIONABLE    = 0x00000002,
	ERROR_SLOT_NOT_PRESENT      = 0x00000004,
	ERROR_DRIVE_NOT_INSTALLED   = 0x00000008,
	ERROR_TRAY_MALFUNCTION      = 0x00000010,
	ERROR_INIT_STATUS_NEEDED    = 0x00000011,
	ERROR_UNHANDLED_ERROR       = 0xFFFFFFFF,
}

struct CHANGER_INITIALIZE_ELEMENT_STATUS {
	CHANGER_ELEMENT_LIST ElementList;
	BOOLEAN BarCodeScan;
}
alias CHANGER_INITIALIZE_ELEMENT_STATUS* PCHANGER_INITIALIZE_ELEMENT_STATUS;

struct CHANGER_SET_POSITION {
	CHANGER_ELEMENT Transport;
	CHANGER_ELEMENT Destination;
	BOOLEAN Flip;
}
alias CHANGER_SET_POSITION* PCHANGER_SET_POSITION;

struct CHANGER_EXCHANGE_MEDIUM {
	CHANGER_ELEMENT Transport;
	CHANGER_ELEMENT Source;
	CHANGER_ELEMENT Destination1;
	CHANGER_ELEMENT Destination2;
	BOOLEAN Flip1;
	BOOLEAN Flip2;
}
alias CHANGER_EXCHANGE_MEDIUM* PCHANGER_EXCHANGE_MEDIUM;

struct CHANGER_MOVE_MEDIUM {
	CHANGER_ELEMENT Transport;
	CHANGER_ELEMENT Source;
	CHANGER_ELEMENT Destination;
	BOOLEAN Flip;
}
alias CHANGER_MOVE_MEDIUM* PCHANGER_MOVE_MEDIUM;

struct CHANGER_SEND_VOLUME_TAG_INFORMATION {
	CHANGER_ELEMENT StartingElement;
	DWORD ActionCode;
	BYTE[MAX_VOLUME_TEMPLATE_SIZE] VolumeIDTemplate;
}
alias CHANGER_SEND_VOLUME_TAG_INFORMATION* PCHANGER_SEND_VOLUME_TAG_INFORMATION;

struct READ_ELEMENT_ADDRESS_INFO {
	DWORD NumberOfElements;
	CHANGER_ELEMENT_STATUS[1] ElementStatus;
}
alias READ_ELEMENT_ADDRESS_INFO* PREAD_ELEMENT_ADDRESS_INFO;

enum {
	SEARCH_ALL         = 0x0,
	SEARCH_PRIMARY     = 0x1,
	SEARCH_ALTERNATE   = 0x2,
	SEARCH_ALL_NO_SEQ  = 0x4,
	SEARCH_PRI_NO_SEQ  = 0x5,
	SEARCH_ALT_NO_SEQ  = 0x6,
	ASSERT_PRIMARY     = 0x8,
	ASSERT_ALTERNATE   = 0x9,
	REPLACE_PRIMARY    = 0xA,
	REPLACE_ALTERNATE  = 0xB,
	UNDEFINE_PRIMARY   = 0xC,
	UNDEFINE_ALTERNATE = 0xD,
}

enum {
	DeviceProblemNone,
	DeviceProblemHardware,
	DeviceProblemCHMError,
	DeviceProblemDoorOpen,
	DeviceProblemCalibrationError,
	DeviceProblemTargetFailure,
	DeviceProblemCHMMoveError,
	DeviceProblemCHMZeroError,
	DeviceProblemCartridgeInsertError,
	DeviceProblemPositionError,
	DeviceProblemSensorError,
	DeviceProblemCartridgeEjectError,
	DeviceProblemGripperError,
	DeviceProblemDriveError
}
alias int CHANGER_DEVICE_PROBLEM_TYPE;
alias CHANGER_DEVICE_PROBLEM_TYPE* PCHANGER_DEVICE_PROBLEM_TYPE;

enum {
	IOCTL_SERIAL_LSRMST_INSERT    = CTL_CODE(FILE_DEVICE_SERIAL_PORT,31,METHOD_BUFFERED,FILE_ANY_ACCESS),
	IOCTL_SERENUM_EXPOSE_HARDWARE = CTL_CODE(FILE_DEVICE_SERENUM,128,METHOD_BUFFERED,FILE_ANY_ACCESS),
	IOCTL_SERENUM_REMOVE_HARDWARE = CTL_CODE(FILE_DEVICE_SERENUM,129,METHOD_BUFFERED,FILE_ANY_ACCESS),
	IOCTL_SERENUM_PORT_DESC       = CTL_CODE(FILE_DEVICE_SERENUM,130,METHOD_BUFFERED,FILE_ANY_ACCESS),
	IOCTL_SERENUM_GET_PORT_NAME   = CTL_CODE(FILE_DEVICE_SERENUM,131,METHOD_BUFFERED,FILE_ANY_ACCESS),
}

enum {
	SERIAL_LSRMST_ESCAPE     = cast(BYTE)0x00,
	SERIAL_LSRMST_LSR_DATA   = cast(BYTE)0x01,
	SERIAL_LSRMST_LSR_NODATA = cast(BYTE)0x02,
	SERIAL_LSRMST_MST        = cast(BYTE)0x03,
}

enum {
	SERIAL_IOC_FCR_FIFO_ENABLE      = cast(DWORD)0x00000001,
	SERIAL_IOC_FCR_RCVR_RESET       = cast(DWORD)0x00000002,
	SERIAL_IOC_FCR_XMIT_RESET       = cast(DWORD)0x00000004,
	SERIAL_IOC_FCR_DMA_MODE         = cast(DWORD)0x00000008,
	SERIAL_IOC_FCR_RES1             = cast(DWORD)0x00000010,
	SERIAL_IOC_FCR_RES2             = cast(DWORD)0x00000020,
	SERIAL_IOC_FCR_RCVR_TRIGGER_LSB = cast(DWORD)0x00000040,
	SERIAL_IOC_FCR_RCVR_TRIGGER_MSB = cast(DWORD)0x00000080,
	SERIAL_IOC_MCR_DTR              = cast(DWORD)0x00000001,
	SERIAL_IOC_MCR_RTS              = cast(DWORD)0x00000002,
	SERIAL_IOC_MCR_OUT1             = cast(DWORD)0x00000004,
	SERIAL_IOC_MCR_OUT2             = cast(DWORD)0x00000008,
	SERIAL_IOC_MCR_LOOP             = cast(DWORD)0x00000010,
}

version(all){//_FILESYSTEMFSCTL_
	enum {
		FSCTL_REQUEST_OPLOCK_LEVEL_1    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 0, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_REQUEST_OPLOCK_LEVEL_2    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 1, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_REQUEST_BATCH_OPLOCK      = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 2, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_OPLOCK_BREAK_ACKNOWLEDGE  = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 3, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_OPBATCH_ACK_CLOSE_PENDING = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 4, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_OPLOCK_BREAK_NOTIFY       = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 5, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_LOCK_VOLUME               = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 6, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_UNLOCK_VOLUME             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 7, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_DISMOUNT_VOLUME           = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 8, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_IS_VOLUME_MOUNTED         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 10, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_IS_PATHNAME_VALID         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 11, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_MARK_VOLUME_DIRTY         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 12, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_QUERY_RETRIEVAL_POINTERS  = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 14, METHOD_NEITHER, FILE_ANY_ACCESS),
		FSCTL_GET_COMPRESSION           = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 15, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_SET_COMPRESSION           = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 16, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA),
		FSCTL_SET_BOOTLOADER_ACCESSED   = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 19, METHOD_NEITHER, FILE_ANY_ACCESS),
		FSCTL_OPLOCK_BREAK_ACK_NO_2     = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 20, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_INVALIDATE_VOLUMES        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 21, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_QUERY_FAT_BPB             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 22, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_REQUEST_FILTER_OPLOCK     = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 23, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_FILESYSTEM_GET_STATISTICS = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 24, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_GET_NTFS_VOLUME_DATA      = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 25, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_GET_NTFS_FILE_RECORD      = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 26, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_GET_VOLUME_BITMAP         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 27, METHOD_NEITHER, FILE_ANY_ACCESS),
		FSCTL_GET_RETRIEVAL_POINTERS    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 28, METHOD_NEITHER, FILE_ANY_ACCESS),
		FSCTL_MOVE_FILE                 = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 29, METHOD_BUFFERED, FILE_SPECIAL_ACCESS),
		FSCTL_IS_VOLUME_DIRTY           = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 30, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_ALLOW_EXTENDED_DASD_IO    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 32, METHOD_NEITHER, FILE_ANY_ACCESS),
		FSCTL_FIND_FILES_BY_SID         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 35, METHOD_NEITHER, FILE_ANY_ACCESS),
		FSCTL_SET_OBJECT_ID             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 38, METHOD_BUFFERED, FILE_SPECIAL_ACCESS),
		FSCTL_GET_OBJECT_ID             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 39, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_DELETE_OBJECT_ID          = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 40, METHOD_BUFFERED, FILE_SPECIAL_ACCESS),
		FSCTL_SET_REPARSE_POINT         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 41, METHOD_BUFFERED, FILE_SPECIAL_ACCESS),
		FSCTL_GET_REPARSE_POINT         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 42, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_DELETE_REPARSE_POINT      = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 43, METHOD_BUFFERED, FILE_SPECIAL_ACCESS),
		FSCTL_ENUM_USN_DATA             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 44, METHOD_NEITHER, FILE_ANY_ACCESS),
		FSCTL_SECURITY_ID_CHECK         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 45, METHOD_NEITHER, FILE_READ_DATA),
		FSCTL_READ_USN_JOURNAL          = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 46, METHOD_NEITHER, FILE_ANY_ACCESS),
		FSCTL_SET_OBJECT_ID_EXTENDED    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 47, METHOD_BUFFERED, FILE_SPECIAL_ACCESS),
		FSCTL_CREATE_OR_GET_OBJECT_ID   = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 48, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_SET_SPARSE                = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 49, METHOD_BUFFERED, FILE_SPECIAL_ACCESS),
		FSCTL_SET_ZERO_DATA             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 50, METHOD_BUFFERED, FILE_WRITE_DATA),
		FSCTL_QUERY_ALLOCATED_RANGES    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 51, METHOD_NEITHER, FILE_READ_DATA),
		FSCTL_ENABLE_UPGRADE            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 52, METHOD_BUFFERED, FILE_WRITE_DATA),
		FSCTL_SET_ENCRYPTION            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 53, METHOD_NEITHER, FILE_ANY_ACCESS),
		FSCTL_ENCRYPTION_FSCTL_IO       = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 54, METHOD_NEITHER, FILE_ANY_ACCESS),
		FSCTL_WRITE_RAW_ENCRYPTED       = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 55, METHOD_NEITHER, FILE_SPECIAL_ACCESS),
		FSCTL_READ_RAW_ENCRYPTED        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 56, METHOD_NEITHER, FILE_SPECIAL_ACCESS),
		FSCTL_CREATE_USN_JOURNAL        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 57, METHOD_NEITHER, FILE_ANY_ACCESS),
		FSCTL_READ_FILE_USN_DATA        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 58, METHOD_NEITHER, FILE_ANY_ACCESS),
		FSCTL_WRITE_USN_CLOSE_RECORD    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 59, METHOD_NEITHER, FILE_ANY_ACCESS),
		FSCTL_EXTEND_VOLUME             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 60, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_QUERY_USN_JOURNAL         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 61, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_DELETE_USN_JOURNAL        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 62, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_MARK_HANDLE               = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 63, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_SIS_COPYFILE              = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 64, METHOD_BUFFERED, FILE_ANY_ACCESS),
		FSCTL_SIS_LINK_FILES            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 65, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA),
		FSCTL_RECALL_FILE               = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 69, METHOD_NEITHER, FILE_ANY_ACCESS),
		FSCTL_READ_FROM_PLEX            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 71, METHOD_OUT_DIRECT, FILE_READ_DATA),
		FSCTL_FILE_PREFETCH             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 72, METHOD_BUFFERED, FILE_SPECIAL_ACCESS),
	//(_WIN32_WINNT >= 0x0600)
			FSCTL_MAKE_MEDIA_COMPATIBLE              = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 76, METHOD_BUFFERED, FILE_WRITE_DATA),
			FSCTL_SET_DEFECT_MANAGEMENT              = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 77, METHOD_BUFFERED, FILE_WRITE_DATA),
			FSCTL_QUERY_SPARING_INFO                 = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 78, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_QUERY_ON_DISK_VOLUME_INFO          = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 79, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_SET_VOLUME_COMPRESSION_STATE       = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 80, METHOD_BUFFERED, FILE_SPECIAL_ACCESS),
			FSCTL_TXFS_MODIFY_RM                     = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 81, METHOD_BUFFERED, FILE_WRITE_DATA),
			FSCTL_TXFS_QUERY_RM_INFORMATION          = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 82, METHOD_BUFFERED, FILE_READ_DATA),
			FSCTL_TXFS_ROLLFORWARD_REDO              = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 84, METHOD_BUFFERED, FILE_WRITE_DATA),
			FSCTL_TXFS_ROLLFORWARD_UNDO              = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 85, METHOD_BUFFERED, FILE_WRITE_DATA),
			FSCTL_TXFS_START_RM                      = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 86, METHOD_BUFFERED, FILE_WRITE_DATA),
			FSCTL_TXFS_SHUTDOWN_RM                   = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 87, METHOD_BUFFERED, FILE_WRITE_DATA),
			FSCTL_TXFS_READ_BACKUP_INFORMATION       = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 88, METHOD_BUFFERED, FILE_READ_DATA),
			FSCTL_TXFS_WRITE_BACKUP_INFORMATION      = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 89, METHOD_BUFFERED, FILE_WRITE_DATA),
			FSCTL_TXFS_CREATE_SECONDARY_RM           = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 90, METHOD_BUFFERED, FILE_WRITE_DATA),
			FSCTL_TXFS_GET_METADATA_INFO             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 91, METHOD_BUFFERED, FILE_READ_DATA),
			FSCTL_TXFS_GET_TRANSACTED_VERSION        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 92, METHOD_BUFFERED, FILE_READ_DATA),
			FSCTL_TXFS_SAVEPOINT_INFORMATION         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 94, METHOD_BUFFERED, FILE_WRITE_DATA),
			FSCTL_TXFS_CREATE_MINIVERSION            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 95, METHOD_BUFFERED, FILE_WRITE_DATA),
			FSCTL_TXFS_TRANSACTION_ACTIVE            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 99, METHOD_BUFFERED, FILE_READ_DATA),
			FSCTL_SET_ZERO_ON_DEALLOCATION           = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 101, METHOD_BUFFERED, FILE_SPECIAL_ACCESS),
			FSCTL_SET_REPAIR                         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 102, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_GET_REPAIR                         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 103, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_WAIT_FOR_REPAIR                    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 104, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_INITIATE_REPAIR                    = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 106, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_CSC_INTERNAL                       = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 107, METHOD_NEITHER, FILE_ANY_ACCESS),
			FSCTL_SHRINK_VOLUME                      = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 108, METHOD_BUFFERED, FILE_SPECIAL_ACCESS),
			FSCTL_SET_SHORT_NAME_BEHAVIOR            = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 109, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_DFSR_SET_GHOST_HANDLE_STATE        = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 110, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_TXFS_LIST_TRANSACTION_LOCKED_FILES = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 120, METHOD_BUFFERED, FILE_READ_DATA),
			FSCTL_TXFS_LIST_TRANSACTIONS             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 121, METHOD_BUFFERED, FILE_READ_DATA),
			FSCTL_QUERY_PAGEFILE_ENCRYPTION          = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 122, METHOD_BUFFERED, FILE_ANY_ACCESS),

	//(_WIN32_WINNT >= 0x0600)
			FSCTL_RESET_VOLUME_ALLOCATION_HINTS = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 123, METHOD_BUFFERED, FILE_ANY_ACCESS),

	//(_WIN32_WINNT >= 0x0601)
			FSCTL_QUERY_DEPENDENT_VOLUME = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 124, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_SD_GLOBAL_CHANGE       = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 125, METHOD_BUFFERED, FILE_ANY_ACCESS),

	//(_WIN32_WINNT >= 0x0600)
			FSCTL_TXFS_READ_BACKUP_INFORMATION2 = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 126, METHOD_BUFFERED, FILE_ANY_ACCESS),

	//(_WIN32_WINNT >= 0x0601)
			FSCTL_LOOKUP_STREAM_FROM_CLUSTER     = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 127, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_TXFS_WRITE_BACKUP_INFORMATION2 = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 128, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_FILE_TYPE_NOTIFICATION         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 129, METHOD_BUFFERED, FILE_ANY_ACCESS),

	//(_WIN32_WINNT >= 0x0601)
			FSCTL_GET_BOOT_AREA_INFO                         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 140, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_GET_RETRIEVAL_POINTER_BASE                 = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 141, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_SET_PERSISTENT_VOLUME_STATE                = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 142, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_QUERY_PERSISTENT_VOLUME_STATE              = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 143, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_REQUEST_OPLOCK                             = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 144, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_CSV_TUNNEL_REQUEST                         = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 145, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_IS_CSV_FILE                                = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 146, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_QUERY_FILE_SYSTEM_RECOGNITION              = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 147, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_CSV_GET_VOLUME_PATH_NAME                   = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 148, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_CSV_GET_VOLUME_NAME_FOR_VOLUME_MOUNT_POINT = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 149, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_CSV_GET_VOLUME_PATH_NAMES_FOR_VOLUME_NAME  = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 150, METHOD_BUFFERED, FILE_ANY_ACCESS),
			FSCTL_IS_FILE_ON_CSV_VOLUME                      = CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 151, METHOD_BUFFERED, FILE_ANY_ACCESS),

		FSCTL_MARK_AS_SYSTEM_HIVE  = FSCTL_SET_BOOTLOADER_ACCESSED,
		//IOCTL_AVIO_ALLOCATE_STREAM = CTL_CODE(FILE_DEVICE_AVIO, 1, METHOD_BUFFERED, FILE_SPECIAL_ACCESS),
		//IOCTL_AVIO_FREE_STREAM     = CTL_CODE(FILE_DEVICE_AVIO, 2, METHOD_BUFFERED, FILE_SPECIAL_ACCESS),
		//IOCTL_AVIO_MODIFY_STREAM   = CTL_CODE(FILE_DEVICE_AVIO, 3, METHOD_BUFFERED, FILE_SPECIAL_ACCESS),
	}

	//(_WIN32_WINNT >= 0x0601)
		struct CSV_NAMESPACE_INFO {
			DWORD Version;
			DWORD DeviceNumber;
			LARGE_INTEGER StartingOffset;
			DWORD SectorSize;
		}
		alias CSV_NAMESPACE_INFO* PCSV_NAMESPACE_INFO;

		enum CSV_NAMESPACE_INFO_V1 = CSV_NAMESPACE_INFO.sizeof;
		enum CSV_INVALID_DEVICE_NUMBER = 0xFFFFFFFF;

	struct PATHNAME_BUFFER {
		DWORD PathNameLength;
		WCHAR[1] Name;
	}
	alias PATHNAME_BUFFER* PPATHNAME_BUFFER;

	struct FSCTL_QUERY_FAT_BPB_BUFFER {
		BYTE[0x24] First0x24BytesOfBootSector;
	}
	alias FSCTL_QUERY_FAT_BPB_BUFFER* PFSCTL_QUERY_FAT_BPB_BUFFER;

	struct NTFS_VOLUME_DATA_BUFFER {
		LARGE_INTEGER VolumeSerialNumber;
		LARGE_INTEGER NumberSectors;
		LARGE_INTEGER TotalClusters;
		LARGE_INTEGER FreeClusters;
		LARGE_INTEGER TotalReserved;
		DWORD BytesPerSector;
		DWORD BytesPerCluster;
		DWORD BytesPerFileRecordSegment;
		DWORD ClustersPerFileRecordSegment;
		LARGE_INTEGER MftValidDataLength;
		LARGE_INTEGER MftStartLcn;
		LARGE_INTEGER Mft2StartLcn;
		LARGE_INTEGER MftZoneStart;
		LARGE_INTEGER MftZoneEnd;
	}
	alias NTFS_VOLUME_DATA_BUFFER* PNTFS_VOLUME_DATA_BUFFER;

	struct NTFS_EXTENDED_VOLUME_DATA {
		DWORD ByteCount;
		WORD MajorVersion;
		WORD MinorVersion;
	}
	alias NTFS_EXTENDED_VOLUME_DATA* PNTFS_EXTENDED_VOLUME_DATA;

	struct STARTING_LCN_INPUT_BUFFER {
		LARGE_INTEGER StartingLcn;
	}
	alias STARTING_LCN_INPUT_BUFFER* PSTARTING_LCN_INPUT_BUFFER;

	struct VOLUME_BITMAP_BUFFER {
		LARGE_INTEGER StartingLcn;
		LARGE_INTEGER BitmapSize;
		BYTE[1] Buffer;
	}
	alias VOLUME_BITMAP_BUFFER* PVOLUME_BITMAP_BUFFER;

	struct STARTING_VCN_INPUT_BUFFER {
		LARGE_INTEGER StartingVcn;
	}
	alias STARTING_VCN_INPUT_BUFFER* PSTARTING_VCN_INPUT_BUFFER;

	struct RETRIEVAL_POINTERS_BUFFER {
		DWORD ExtentCount;
		LARGE_INTEGER StartingVcn;
		struct RETRIEVAL_POINTERS_BUFFER {
			LARGE_INTEGER NextVcn;
			LARGE_INTEGER Lcn;
		}
		RETRIEVAL_POINTERS_BUFFER[1] Extents;
	}
	alias RETRIEVAL_POINTERS_BUFFER* PRETRIEVAL_POINTERS_BUFFER;

	struct NTFS_FILE_RECORD_INPUT_BUFFER {
		LARGE_INTEGER FileReferenceNumber;
	}
	alias NTFS_FILE_RECORD_INPUT_BUFFER* PNTFS_FILE_RECORD_INPUT_BUFFER;

	struct NTFS_FILE_RECORD_OUTPUT_BUFFER {
		LARGE_INTEGER FileReferenceNumber;
		DWORD FileRecordLength;
		BYTE[1] FileRecordBuffer;
	}
	alias NTFS_FILE_RECORD_OUTPUT_BUFFER* PNTFS_FILE_RECORD_OUTPUT_BUFFER;

	struct MOVE_FILE_DATA {
		HANDLE FileHandle;
		LARGE_INTEGER StartingVcn;
		LARGE_INTEGER StartingLcn;
		DWORD ClusterCount;
	}
	alias MOVE_FILE_DATA* PMOVE_FILE_DATA;

	struct MOVE_FILE_RECORD_DATA {
		HANDLE FileHandle;
		LARGE_INTEGER SourceFileRecord;
		LARGE_INTEGER TargetFileRecord;
	}
	alias MOVE_FILE_RECORD_DATA* PMOVE_FILE_RECORD_DATA;

	version(Win64){
		struct MOVE_FILE_DATA32 {
			UINT32 FileHandle;
			LARGE_INTEGER StartingVcn;
			LARGE_INTEGER StartingLcn;
			DWORD ClusterCount;
		}
		alias MOVE_FILE_DATA32* PMOVE_FILE_DATA32;
	}

	struct FIND_BY_SID_DATA {
		DWORD Restart;
		SID Sid;
	}
	alias FIND_BY_SID_DATA* PFIND_BY_SID_DATA;

	struct FIND_BY_SID_OUTPUT {
		DWORD NextEntryOffset;
		DWORD FileIndex;
		DWORD FileNameLength;
		WCHAR[1] FileName;
	}
	alias FIND_BY_SID_OUTPUT* PFIND_BY_SID_OUTPUT;

	struct MFT_ENUM_DATA {
		DWORDLONG StartFileReferenceNumber;
		USN LowUsn;
		USN HighUsn;
	}
	alias MFT_ENUM_DATA* PMFT_ENUM_DATA;

	struct CREATE_USN_JOURNAL_DATA {
		DWORDLONG MaximumSize;
		DWORDLONG AllocationDelta;
	}
	alias CREATE_USN_JOURNAL_DATA* PCREATE_USN_JOURNAL_DATA;

	struct READ_USN_JOURNAL_DATA {
		USN StartUsn;
		DWORD ReasonMask;
		DWORD ReturnOnlyOnClose;
		DWORDLONG Timeout;
		DWORDLONG BytesToWaitFor;
		DWORDLONG UsnJournalID;
	}
	alias READ_USN_JOURNAL_DATA* PREAD_USN_JOURNAL_DATA;

	struct USN_RECORD {
		DWORD RecordLength;
		WORD MajorVersion;
		WORD MinorVersion;
		DWORDLONG FileReferenceNumber;
		DWORDLONG ParentFileReferenceNumber;
		USN Usn;
		LARGE_INTEGER TimeStamp;
		DWORD Reason;
		DWORD SourceInfo;
		DWORD SecurityId;
		DWORD FileAttributes;
		WORD FileNameLength;
		WORD FileNameOffset;
		WCHAR[1] FileName;
	}
	alias USN_RECORD* PUSN_RECORD;

	enum USN_PAGE_SIZE = (0x1000);

	enum {
		USN_REASON_DATA_OVERWRITE        = 0x00000001,
		USN_REASON_DATA_EXTEND           = 0x00000002,
		USN_REASON_DATA_TRUNCATION       = 0x00000004,
		USN_REASON_NAMED_DATA_OVERWRITE  = 0x00000010,
		USN_REASON_NAMED_DATA_EXTEND     = 0x00000020,
		USN_REASON_NAMED_DATA_TRUNCATION = 0x00000040,
		USN_REASON_FILE_CREATE           = 0x00000100,
		USN_REASON_FILE_DELETE           = 0x00000200,
		USN_REASON_EA_CHANGE             = 0x00000400,
		USN_REASON_SECURITY_CHANGE       = 0x00000800,
		USN_REASON_RENAME_OLD_NAME       = 0x00001000,
		USN_REASON_RENAME_NEW_NAME       = 0x00002000,
		USN_REASON_INDEXABLE_CHANGE      = 0x00004000,
		USN_REASON_BASIC_INFO_CHANGE     = 0x00008000,
		USN_REASON_HARD_LINK_CHANGE      = 0x00010000,
		USN_REASON_COMPRESSION_CHANGE    = 0x00020000,
		USN_REASON_ENCRYPTION_CHANGE     = 0x00040000,
		USN_REASON_OBJECT_ID_CHANGE      = 0x00080000,
		USN_REASON_REPARSE_POINT_CHANGE  = 0x00100000,
		USN_REASON_STREAM_CHANGE         = 0x00200000,
		USN_REASON_TRANSACTED_CHANGE     = 0x00400000,
		USN_REASON_CLOSE                 = 0x80000000,
	}

	struct USN_JOURNAL_DATA {
		DWORDLONG UsnJournalID;
		USN FirstUsn;
		USN NextUsn;
		USN LowestValidUsn;
		USN MaxUsn;
		DWORDLONG MaximumSize;
		DWORDLONG AllocationDelta;
	}
	alias USN_JOURNAL_DATA* PUSN_JOURNAL_DATA;

	struct DELETE_USN_JOURNAL_DATA {
		DWORDLONG UsnJournalID;
		DWORD DeleteFlags;
	}
	alias DELETE_USN_JOURNAL_DATA* PDELETE_USN_JOURNAL_DATA;

	enum {
		USN_DELETE_FLAG_DELETE = 0x00000001,
		USN_DELETE_FLAG_NOTIFY = 0x00000002,
		USN_DELETE_VALID_FLAGS = 0x00000003,
	}

	struct MARK_HANDLE_INFO {
		DWORD UsnSourceInfo;
		HANDLE VolumeHandle;
		DWORD HandleInfo;
	}
	alias MARK_HANDLE_INFO* PMARK_HANDLE_INFO;

	version(Win64){
		struct MARK_HANDLE_INFO32 {
			DWORD UsnSourceInfo;
			UINT32 VolumeHandle;
			DWORD HandleInfo;
		}
		alias MARK_HANDLE_INFO32* PMARK_HANDLE_INFO32;
	}

	enum {
		USN_SOURCE_DATA_MANAGEMENT        = 0x00000001,
		USN_SOURCE_AUXILIARY_DATA         = 0x00000002,
		USN_SOURCE_REPLICATION_MANAGEMENT = 0x00000004,
	}

	enum {
		MARK_HANDLE_PROTECT_CLUSTERS   = 0x00000001,
		MARK_HANDLE_TXF_SYSTEM_LOG     = 0x00000004,
		MARK_HANDLE_NOT_TXF_SYSTEM_LOG = 0x00000008,
	}

	//_WIN32_WINNT >= 0x0601
		enum {
			MARK_HANDLE_REALTIME                                 = 0x00000020,
			MARK_HANDLE_NOT_REALTIME                             = 0x00000040,
			NO_8DOT3_NAME_PRESENT                                = 0x00000001,
			REMOVED_8DOT3_NAME                                   = 0x00000002,
			PERSISTENT_VOLUME_STATE_SHORT_NAME_CREATION_DISABLED = 0x00000001,
		}

	struct BULK_SECURITY_TEST_DATA {
		ACCESS_MASK DesiredAccess;
		DWORD[1] SecurityIds;
	}
	alias BULK_SECURITY_TEST_DATA* PBULK_SECURITY_TEST_DATA;

	enum {
		VOLUME_IS_DIRTY          = 0x00000001,
		VOLUME_UPGRADE_SCHEDULED = 0x00000002,
		VOLUME_SESSION_OPEN      = 0x00000004,
	}

	struct FILE_PREFETCH {
		DWORD Type;
		DWORD Count;
		DWORDLONG[1] Prefetch;
	}
	alias FILE_PREFETCH* PFILE_PREFETCH;

	struct FILE_PREFETCH_EX {
		DWORD Type;
		DWORD Count;
		PVOID Context;
		DWORDLONG[1] Prefetch;
	} 
	alias FILE_PREFETCH_EX* PFILE_PREFETCH_EX;

	enum {
		FILE_PREFETCH_TYPE_FOR_CREATE     = 0x1,
		FILE_PREFETCH_TYPE_FOR_DIRENUM    = 0x2,
		FILE_PREFETCH_TYPE_FOR_CREATE_EX  = 0x3,
		FILE_PREFETCH_TYPE_FOR_DIRENUM_EX = 0x4,
		FILE_PREFETCH_TYPE_MAX            = 0x4,
	}

	struct FILESYSTEM_STATISTICS {
		WORD FileSystemType;
		WORD Version;
		DWORD SizeOfCompleteStructure;
		DWORD UserFileReads;
		DWORD UserFileReadBytes;
		DWORD UserDiskReads;
		DWORD UserFileWrites;
		DWORD UserFileWriteBytes;
		DWORD UserDiskWrites;
		DWORD MetaDataReads;
		DWORD MetaDataReadBytes;
		DWORD MetaDataDiskReads;
		DWORD MetaDataWrites;
		DWORD MetaDataWriteBytes;
		DWORD MetaDataDiskWrites;
	}
	alias FILESYSTEM_STATISTICS* PFILESYSTEM_STATISTICS;

	enum {
		FILESYSTEM_STATISTICS_TYPE_NTFS  = 1,
		FILESYSTEM_STATISTICS_TYPE_FAT   = 2,
		FILESYSTEM_STATISTICS_TYPE_EXFAT = 3,
	}

	struct FAT_STATISTICS {
		DWORD CreateHits;
		DWORD SuccessfulCreates;
		DWORD FailedCreates;
		DWORD NonCachedReads;
		DWORD NonCachedReadBytes;
		DWORD NonCachedWrites;
		DWORD NonCachedWriteBytes;
		DWORD NonCachedDiskReads;
		DWORD NonCachedDiskWrites;
	}
	alias FAT_STATISTICS* PFAT_STATISTICS;

	struct EXFAT_STATISTICS {
		DWORD CreateHits;
		DWORD SuccessfulCreates;
		DWORD FailedCreates;
		DWORD NonCachedReads;
		DWORD NonCachedReadBytes;
		DWORD NonCachedWrites;
		DWORD NonCachedWriteBytes;
		DWORD NonCachedDiskReads;
		DWORD NonCachedDiskWrites;
	}
	alias EXFAT_STATISTICS* PEXFAT_STATISTICS;

	struct NTFS_STATISTICS {
		DWORD LogFileFullExceptions;
		DWORD OtherExceptions;
		DWORD MftReads;
		DWORD MftReadBytes;
		DWORD MftWrites;
		DWORD MftWriteBytes;
		struct MftWritesUserLevel_ {
			WORD Write;
			WORD Create;
			WORD SetInfo;
			WORD Flush;
		}
		MftWritesUserLevel_ MftWritesUserLevel;
		WORD MftWritesFlushForLogFileFull;
		WORD MftWritesLazyWriter;
		WORD MftWritesUserRequest;
		DWORD Mft2Writes;
		DWORD Mft2WriteBytes;
		struct Mft2WritesUserLevel_ {
			WORD Write;
			WORD Create;
			WORD SetInfo;
			WORD Flush;
		}
		Mft2WritesUserLevel_ Mft2WritesUserLevel;
		WORD Mft2WritesFlushForLogFileFull;
		WORD Mft2WritesLazyWriter;
		WORD Mft2WritesUserRequest;
		DWORD RootIndexReads;
		DWORD RootIndexReadBytes;
		DWORD RootIndexWrites;
		DWORD RootIndexWriteBytes;
		DWORD BitmapReads;
		DWORD BitmapReadBytes;
		DWORD BitmapWrites;
		DWORD BitmapWriteBytes;
		WORD BitmapWritesFlushForLogFileFull;
		WORD BitmapWritesLazyWriter;
		WORD BitmapWritesUserRequest;
		struct BitmapWritesUserLevel_ {
			WORD Write;
			WORD Create;
			WORD SetInfo;
		}
		BitmapWritesUserLevel_ BitmapWritesUserLevel;
		struct MftBitmapWritesUserLevel_ {
			WORD Write;
			WORD Create;
			WORD SetInfo;
			WORD Flush;
		}
		MftBitmapWritesUserLevel_ MftBitmapWritesUserLevel;
		DWORD UserIndexReads;
		DWORD UserIndexReadBytes;
		DWORD UserIndexWrites;
		DWORD UserIndexWriteBytes;
		DWORD LogFileReads;
		DWORD LogFileReadBytes;
		DWORD LogFileWrites;
		DWORD LogFileWriteBytes;
		struct Allocate_ {
			DWORD Calls;
			DWORD Clusters;
			DWORD Hints;
			DWORD RunsReturned;
			DWORD HintsHonored;
			DWORD HintsClusters;
			DWORD Cache;
			DWORD CacheClusters;
			DWORD CacheMiss;
			DWORD CacheMissClusters;
		}
		Allocate_ Allocate;
	}
	alias NTFS_STATISTICS* PNTFS_STATISTICS;

	struct FILE_OBJECTID_BUFFER {
		BYTE[16] ObjectId;
		union {
			struct {
				BYTE[16] BirthVolumeId;
				BYTE[16] BirthObjectId;
				BYTE[16] DomainId;
			}
			BYTE[48] ExtendedInfo;
		}
	}
	alias FILE_OBJECTID_BUFFER* PFILE_OBJECTID_BUFFER;

	struct FILE_SET_SPARSE_BUFFER {
		BOOLEAN SetSparse;
	}
	alias FILE_SET_SPARSE_BUFFER* PFILE_SET_SPARSE_BUFFER;

	struct FILE_ZERO_DATA_INFORMATION {
		LARGE_INTEGER FileOffset;
		LARGE_INTEGER BeyondFinalZero;
	}
	alias FILE_ZERO_DATA_INFORMATION* PFILE_ZERO_DATA_INFORMATION;

	struct FILE_ALLOCATED_RANGE_BUFFER {
		LARGE_INTEGER FileOffset;
		LARGE_INTEGER Length;
	}
	alias FILE_ALLOCATED_RANGE_BUFFER* PFILE_ALLOCATED_RANGE_BUFFER;

	struct ENCRYPTION_BUFFER {
		DWORD EncryptionOperation;
		BYTE[1] Private;
	}
	alias ENCRYPTION_BUFFER* PENCRYPTION_BUFFER;

	enum {
		FILE_SET_ENCRYPTION      = 0x00000001,
		FILE_CLEAR_ENCRYPTION    = 0x00000002,
		STREAM_SET_ENCRYPTION    = 0x00000003,
		STREAM_CLEAR_ENCRYPTION  = 0x00000004,
		MAXIMUM_ENCRYPTION_VALUE = 0x00000004,
	}

	struct DECRYPTION_STATUS_BUFFER {
		BOOLEAN NoEncryptedStreams;
	}
	alias DECRYPTION_STATUS_BUFFER* PDECRYPTION_STATUS_BUFFER;

	enum {
		ENCRYPTION_FORMAT_DEFAULT = 0x01,
		COMPRESSION_FORMAT_SPARSE = 0x4000,
	}

	struct REQUEST_RAW_ENCRYPTED_DATA {
		LONGLONG FileOffset;
		DWORD Length;
	}
	alias REQUEST_RAW_ENCRYPTED_DATA* PREQUEST_RAW_ENCRYPTED_DATA;

	struct ENCRYPTED_DATA_INFO {
		DWORDLONG StartingFileOffset;
		DWORD OutputBufferOffset;
		DWORD BytesWithinFileSize;
		DWORD BytesWithinValidDataLength;
		WORD CompressionFormat;
		BYTE DataUnitShift;
		BYTE ChunkShift;
		BYTE ClusterShift;
		BYTE EncryptionFormat;
		WORD NumberOfDataBlocks;
		DWORD[ANYSIZE_ARRAY] DataBlockSize;
	}
	alias ENCRYPTED_DATA_INFO *PENCRYPTED_DATA_INFO;

	struct PLEX_READ_DATA_REQUEST {
		LARGE_INTEGER ByteOffset;
		DWORD ByteLength;
		DWORD PlexNumber;
	}
	alias PLEX_READ_DATA_REQUEST* PPLEX_READ_DATA_REQUEST;

	struct SI_COPYFILE {
		DWORD SourceFileNameLength;
		DWORD DestinationFileNameLength;
		DWORD Flags;
		WCHAR[1] FileNameBuffer;
	}
	alias SI_COPYFILE* PSI_COPYFILE;

	enum {
		COPYFILE_SIS_LINK    = 0x0001,
		COPYFILE_SIS_REPLACE = 0x0002,
		COPYFILE_SIS_FLAGS   = 0x0003,
	}

	struct FILE_MAKE_COMPATIBLE_BUFFER {
		BOOLEAN CloseDisc;
	}
	alias FILE_MAKE_COMPATIBLE_BUFFER* PFILE_MAKE_COMPATIBLE_BUFFER;

	struct FILE_SET_DEFECT_MGMT_BUFFER {
		BOOLEAN Disable;
	}
	alias FILE_SET_DEFECT_MGMT_BUFFER* PFILE_SET_DEFECT_MGMT_BUFFER;

	struct FILE_QUERY_SPARING_BUFFER {
		DWORD SparingUnitBytes;
		BOOLEAN SoftwareSparing;
		DWORD TotalSpareBlocks;
		DWORD FreeSpareBlocks;
	}
	alias FILE_QUERY_SPARING_BUFFER* PFILE_QUERY_SPARING_BUFFER;

	struct FILE_QUERY_ON_DISK_VOL_INFO_BUFFER {
		LARGE_INTEGER DirectoryCount;
		LARGE_INTEGER FileCount;
		WORD FsFormatMajVersion;
		WORD FsFormatMinVersion;
		WCHAR[ 12] FsFormatName;
		LARGE_INTEGER FormatTime;
		LARGE_INTEGER LastUpdateTime;
		WCHAR[ 34] CopyrightInfo;
		WCHAR[ 34] AbstractInfo;
		WCHAR[ 34] FormattingImplementationInfo;
		WCHAR[ 34] LastModifyingImplementationInfo;
	}
	alias FILE_QUERY_ON_DISK_VOL_INFO_BUFFER* PFILE_QUERY_ON_DISK_VOL_INFO_BUFFER;

	enum {
		SET_REPAIR_ENABLED                          = 0x00000001,
		SET_REPAIR_VOLUME_BITMAP_SCAN               = 0x00000002,
		SET_REPAIR_DELETE_CROSSLINK                 = 0x00000004,
		SET_REPAIR_WARN_ABOUT_DATA_LOSS             = 0x00000008,
		SET_REPAIR_DISABLED_AND_BUGCHECK_ON_CORRUPT = 0x00000010,
		SET_REPAIR_VALID_MASK                       = 0x0000001F,
	}

	enum {
		ShrinkPrepare = 1,
		ShrinkCommit,
		ShrinkAbort
	}
	alias int SHRINK_VOLUME_REQUEST_TYPES;
	alias SHRINK_VOLUME_REQUEST_TYPES* PSHRINK_VOLUME_REQUEST_TYPES;

	struct SHRINK_VOLUME_INFORMATION {
		SHRINK_VOLUME_REQUEST_TYPES ShrinkRequestType;
		DWORDLONG Flags;
		LONGLONG NewNumberOfSectors;
	}
	alias SHRINK_VOLUME_INFORMATION* PSHRINK_VOLUME_INFORMATION;

	enum {
		TXFS_RM_FLAG_LOGGING_MODE                        = 0x00000001,
		TXFS_RM_FLAG_RENAME_RM                           = 0x00000002,
		TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX             = 0x00000004,
		TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN             = 0x00000008,
		TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS = 0x00000010,
		TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT        = 0x00000020,
		TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE          = 0x00000040,
		TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX          = 0x00000080,
		TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN          = 0x00000100,
		TXFS_RM_FLAG_GROW_LOG                            = 0x00000400,
		TXFS_RM_FLAG_SHRINK_LOG                          = 0x00000800,
		TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE                = 0x00001000,
		TXFS_RM_FLAG_PRESERVE_CHANGES                    = 0x00002000,
		TXFS_RM_FLAG_RESET_RM_AT_NEXT_START              = 0x00004000,
		TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START       = 0x00008000,
		TXFS_RM_FLAG_PREFER_CONSISTENCY                  = 0x00010000,
		TXFS_RM_FLAG_PREFER_AVAILABILITY                 = 0x00020000,
	}

	enum {
		TXFS_LOGGING_MODE_SIMPLE = 0x0001,
		TXFS_LOGGING_MODE_FULL   = 0x0002,
	}

	enum {
		TXFS_TRANSACTION_STATE_NONE      = 0x00,
		TXFS_TRANSACTION_STATE_ACTIVE    = 0x01,
		TXFS_TRANSACTION_STATE_PREPARED  = 0x02,
		TXFS_TRANSACTION_STATE_NOTACTIVE = 0x03,
		TXFS_MODIFY_RM_VALID_FLAGS       = TXFS_RM_FLAG_LOGGING_MODE |  TXFS_RM_FLAG_RENAME_RM |  TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX |  TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN |  TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS |  TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT |  TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE |  TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX |  TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN |  TXFS_RM_FLAG_SHRINK_LOG |  TXFS_RM_FLAG_GROW_LOG |  TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE |  TXFS_RM_FLAG_PRESERVE_CHANGES |  TXFS_RM_FLAG_RESET_RM_AT_NEXT_START |  TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START |  TXFS_RM_FLAG_PREFER_CONSISTENCY |  TXFS_RM_FLAG_PREFER_AVAILABILITY,
	}

	struct TXFS_MODIFY_RM {
		DWORD Flags;
		DWORD LogContainerCountMax;
		DWORD LogContainerCountMin;
		DWORD LogContainerCount;
		DWORD LogGrowthIncrement;
		DWORD LogAutoShrinkPercentage;
		DWORDLONG Reserved;
		WORD LoggingMode;
	}
	alias TXFS_MODIFY_RM* PTXFS_MODIFY_RM;

	enum {
		TXFS_RM_STATE_NOT_STARTED             = 0,
		TXFS_RM_STATE_STARTING                = 1,
		TXFS_RM_STATE_ACTIVE                  = 2,
		TXFS_RM_STATE_SHUTTING_DOWN           = 3,
		TXFS_QUERY_RM_INFORMATION_VALID_FLAGS = TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS |  TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT |  TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX |  TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN |  TXFS_RM_FLAG_RESET_RM_AT_NEXT_START |  TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START |  TXFS_RM_FLAG_PREFER_CONSISTENCY |  TXFS_RM_FLAG_PREFER_AVAILABILITY,
	}

	struct TXFS_QUERY_RM_INFORMATION {
		DWORD BytesRequired;
		DWORDLONG TailLsn;
		DWORDLONG CurrentLsn;
		DWORDLONG ArchiveTailLsn;
		DWORDLONG LogContainerSize;
		LARGE_INTEGER HighestVirtualClock;
		DWORD LogContainerCount;
		DWORD LogContainerCountMax;
		DWORD LogContainerCountMin;
		DWORD LogGrowthIncrement;
		DWORD LogAutoShrinkPercentage;
		DWORD Flags;
		WORD LoggingMode;
		WORD Reserved;
		DWORD RmState;
		DWORDLONG LogCapacity;
		DWORDLONG LogFree;
		DWORDLONG TopsSize;
		DWORDLONG TopsUsed;
		DWORDLONG TransactionCount;
		DWORDLONG OnePCCount;
		DWORDLONG TwoPCCount;
		DWORDLONG NumberLogFileFull;
		DWORDLONG OldestTransactionAge;
		GUID RMName;
		DWORD TmLogPathOffset;
	}
	alias TXFS_QUERY_RM_INFORMATION* PTXFS_QUERY_RM_INFORMATION;

	enum {
		TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN      = 0x01,
		TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK = 0x02,
		TXFS_ROLLFORWARD_REDO_VALID_FLAGS                 = TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN |  TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK,
	}

	struct TXFS_ROLLFORWARD_REDO_INFORMATION {
		LARGE_INTEGER LastVirtualClock;
		DWORDLONG LastRedoLsn;
		DWORDLONG HighestRecoveryLsn;
		DWORD Flags;
	}
	alias TXFS_ROLLFORWARD_REDO_INFORMATION* PTXFS_ROLLFORWARD_REDO_INFORMATION;

	enum {
		TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX             = 0x00000001,
		TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN             = 0x00000002,
		TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE                  = 0x00000004,
		TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS = 0x00000008,
		TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT        = 0x00000010,
		TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE          = 0x00000020,
		TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX          = 0x00000040,
		TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN          = 0x00000080,
		TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT                 = 0x00000200,
		TXFS_START_RM_FLAG_LOGGING_MODE                        = 0x00000400,
		TXFS_START_RM_FLAG_PRESERVE_CHANGES                    = 0x00000800,
		TXFS_START_RM_FLAG_PREFER_CONSISTENCY                  = 0x00001000,
		TXFS_START_RM_FLAG_PREFER_AVAILABILITY                 = 0x00002000,
		TXFS_START_RM_VALID_FLAGS                              = TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX |  TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN |  TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE |  TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS |  TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT |  TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE |  TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT |  TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX |  TXFS_START_RM_FLAG_LOGGING_MODE |  TXFS_START_RM_FLAG_PRESERVE_CHANGES |  TXFS_START_RM_FLAG_PREFER_CONSISTENCY |  TXFS_START_RM_FLAG_PREFER_AVAILABILITY,
	}

	struct TXFS_START_RM_INFORMATION {
		DWORD Flags;
		DWORDLONG LogContainerSize;
		DWORD LogContainerCountMin;
		DWORD LogContainerCountMax;
		DWORD LogGrowthIncrement;
		DWORD LogAutoShrinkPercentage;
		DWORD TmLogPathOffset;
		WORD TmLogPathLength;
		WORD LoggingMode;
		WORD LogPathLength;
		WORD Reserved;
		WCHAR[1] LogPath;
	}
	alias TXFS_START_RM_INFORMATION* PTXFS_START_RM_INFORMATION;

	struct TXFS_GET_METADATA_INFO_OUT {
		struct {
			LONGLONG LowPart;
			LONGLONG HighPart;
		}// TxfFileId;
		GUID LockingTransaction;
		DWORDLONG LastLsn;
		DWORD TransactionState;
	}
	alias TXFS_GET_METADATA_INFO_OUT* PTXFS_GET_METADATA_INFO_OUT;

	enum {
		TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_CREATED = 0x00000001,
		TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_DELETED = 0x00000002,
	}

	struct TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY {
		DWORDLONG Offset;
		DWORD NameFlags;
		LONGLONG FileId;
		DWORD Reserved1;
		DWORD Reserved2;
		LONGLONG Reserved3;
		WCHAR[1] FileName;
	}
	alias TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY* PTXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY;

	struct TXFS_LIST_TRANSACTION_LOCKED_FILES {
		GUID KtmTransaction;
		DWORDLONG NumberOfFiles;
		DWORDLONG BufferSizeRequired;
		DWORDLONG Offset;
	}
	alias TXFS_LIST_TRANSACTION_LOCKED_FILES* PTXFS_LIST_TRANSACTION_LOCKED_FILES;

	struct TXFS_LIST_TRANSACTIONS_ENTRY {
		GUID TransactionId;
		DWORD TransactionState;
		DWORD Reserved1;
		DWORD Reserved2;
		LONGLONG Reserved3;
	}
	alias TXFS_LIST_TRANSACTIONS_ENTRY* PTXFS_LIST_TRANSACTIONS_ENTRY;

	struct TXFS_LIST_TRANSACTIONS {
		DWORDLONG NumberOfTransactions;
		DWORDLONG BufferSizeRequired;
	}
	alias TXFS_LIST_TRANSACTIONS* PTXFS_LIST_TRANSACTIONS;

	struct TXFS_READ_BACKUP_INFORMATION_OUT {
		union {
			DWORD BufferLength;
			BYTE[1] Buffer;
		}
	}
	alias TXFS_READ_BACKUP_INFORMATION_OUT* PTXFS_READ_BACKUP_INFORMATION_OUT;

	struct TXFS_WRITE_BACKUP_INFORMATION {
		BYTE[1] Buffer;
	}
	alias TXFS_WRITE_BACKUP_INFORMATION* PTXFS_WRITE_BACKUP_INFORMATION;

	enum {
		TXFS_TRANSACTED_VERSION_NONTRANSACTED = 0xFFFFFFFE,
		TXFS_TRANSACTED_VERSION_UNCOMMITTED   = 0xFFFFFFFF,
	}

	struct TXFS_GET_TRANSACTED_VERSION {
		DWORD ThisBaseVersion;
		DWORD LatestVersion;
		WORD ThisMiniVersion;
		WORD FirstMiniVersion;
		WORD LatestMiniVersion;
	}
	alias TXFS_GET_TRANSACTED_VERSION* PTXFS_GET_TRANSACTED_VERSION;

	enum {
		TXFS_SAVEPOINT_SET       = 0x00000001,
		TXFS_SAVEPOINT_ROLLBACK  = 0x00000002,
		TXFS_SAVEPOINT_CLEAR     = 0x00000004,
		TXFS_SAVEPOINT_CLEAR_ALL = 0x00000010,
	}

	struct TXFS_SAVEPOINT_INFORMATION {
		HANDLE KtmTransaction;
		DWORD ActionCode;
		DWORD SavepointId;
	}
	alias TXFS_SAVEPOINT_INFORMATION* PTXFS_SAVEPOINT_INFORMATION;

	struct TXFS_CREATE_MINIVERSION_INFO {
		WORD StructureVersion;
		WORD StructureLength;
		DWORD BaseVersion;
		WORD MiniVersion;
	}
	alias TXFS_CREATE_MINIVERSION_INFO* PTXFS_CREATE_MINIVERSION_INFO;

	struct TXFS_TRANSACTION_ACTIVE_INFO {
		BOOLEAN TransactionsActiveAtSnapshot;
	}
	alias TXFS_TRANSACTION_ACTIVE_INFO* PTXFS_TRANSACTION_ACTIVE_INFO;

	//_WIN32_WINNT >= 0x0601
		struct BOOT_AREA_INFO {
			DWORD BootSectorCount;
			struct BootSectors_ {
				LARGE_INTEGER Offset;
			}
			BootSectors_[2] BootSectors;
		}
		alias BOOT_AREA_INFO* PBOOT_AREA_INFO;

		struct RETRIEVAL_POINTER_BASE {
			LARGE_INTEGER FileAreaOffset;
		}
		alias RETRIEVAL_POINTER_BASE* PRETRIEVAL_POINTER_BASE;

		struct FILE_FS_PERSISTENT_VOLUME_INFORMATION {
			DWORD VolumeFlags;
			DWORD FlagMask;
			DWORD Version;
			DWORD Reserved;
		}
		alias FILE_FS_PERSISTENT_VOLUME_INFORMATION* PFILE_FS_PERSISTENT_VOLUME_INFORMATION;

		struct FILE_SYSTEM_RECOGNITION_INFORMATION {
			CHAR[9] FileSystem;
		}
		alias FILE_SYSTEM_RECOGNITION_INFORMATION* PFILE_SYSTEM_RECOGNITION_INFORMATION;

		enum {
			OPLOCK_LEVEL_CACHE_READ   = 0x00000001,
			OPLOCK_LEVEL_CACHE_HANDLE = 0x00000002,
			OPLOCK_LEVEL_CACHE_WRITE  = 0x00000004,
		}
		enum {
			REQUEST_OPLOCK_INPUT_FLAG_REQUEST               = 0x00000001,
			REQUEST_OPLOCK_INPUT_FLAG_ACK                   = 0x00000002,
			REQUEST_OPLOCK_INPUT_FLAG_COMPLETE_ACK_ON_CLOSE = 0x00000004,
		}
		enum REQUEST_OPLOCK_CURRENT_VERSION = 1;

		struct REQUEST_OPLOCK_INPUT_BUFFER {
			WORD StructureVersion;
			WORD StructureLength;
			DWORD RequestedOplockLevel;
			DWORD Flags;
		}
		alias REQUEST_OPLOCK_INPUT_BUFFER* PREQUEST_OPLOCK_INPUT_BUFFER;

		enum {
			REQUEST_OPLOCK_OUTPUT_FLAG_ACK_REQUIRED   = 0x00000001,
			REQUEST_OPLOCK_OUTPUT_FLAG_MODES_PROVIDED = 0x00000002,
		}

		struct REQUEST_OPLOCK_OUTPUT_BUFFER {
			WORD StructureVersion;
			WORD StructureLength;
			DWORD OriginalOplockLevel;
			DWORD NewOplockLevel;
			DWORD Flags;
			ACCESS_MASK AccessMode;
			WORD ShareMode;
		}
		alias REQUEST_OPLOCK_OUTPUT_BUFFER* PREQUEST_OPLOCK_OUTPUT_BUFFER;

		enum SD_GLOBAL_CHANGE_TYPE_MACHINE_SID = 1;

		struct SD_CHANGE_MACHINE_SID_INPUT {
			WORD CurrentMachineSIDOffset;
			WORD CurrentMachineSIDLength;
			WORD NewMachineSIDOffset;
			WORD NewMachineSIDLength;
		}
		alias SD_CHANGE_MACHINE_SID_INPUT* PSD_CHANGE_MACHINE_SID_INPUT;

		struct SD_CHANGE_MACHINE_SID_OUTPUT {
			DWORDLONG NumSDChangedSuccess;
			DWORDLONG NumSDChangedFail;
			DWORDLONG NumSDUnused;
			DWORDLONG NumSDTotal;
			DWORDLONG NumMftSDChangedSuccess;
			DWORDLONG NumMftSDChangedFail;
			DWORDLONG NumMftSDTotal;
		}
		alias SD_CHANGE_MACHINE_SID_OUTPUT* PSD_CHANGE_MACHINE_SID_OUTPUT;

		struct SD_GLOBAL_CHANGE_INPUT {
			DWORD Flags;
			DWORD ChangeType;
			union {
				SD_CHANGE_MACHINE_SID_INPUT SdChange;
			}
		}
		alias SD_GLOBAL_CHANGE_INPUT* PSD_GLOBAL_CHANGE_INPUT;

		struct SD_GLOBAL_CHANGE_OUTPUT {
			DWORD Flags;
			DWORD ChangeType;
			union {
				SD_CHANGE_MACHINE_SID_OUTPUT SdChange;
			}
		}
		alias SD_GLOBAL_CHANGE_OUTPUT* PSD_GLOBAL_CHANGE_OUTPUT;

		enum ENCRYPTED_DATA_INFO_SPARSE_FILE = 1;

		struct EXTENDED_ENCRYPTED_DATA_INFO {
			DWORD ExtendedCode;
			DWORD Length;
			DWORD Flags;
			DWORD Reserved;
		}
		alias EXTENDED_ENCRYPTED_DATA_INFO* PEXTENDED_ENCRYPTED_DATA_INFO;

		struct LOOKUP_STREAM_FROM_CLUSTER_INPUT {
			DWORD Flags;
			DWORD NumberOfClusters;
			LARGE_INTEGER Cluster[1];
		}
		alias LOOKUP_STREAM_FROM_CLUSTER_INPUT* PLOOKUP_STREAM_FROM_CLUSTER_INPUT;

		struct LOOKUP_STREAM_FROM_CLUSTER_OUTPUT {
			DWORD Offset;
			DWORD NumberOfMatches;
			DWORD BufferSizeRequired;
		}
		alias LOOKUP_STREAM_FROM_CLUSTER_OUTPUT* PLOOKUP_STREAM_FROM_CLUSTER_OUTPUT;

		enum {
			LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_PAGE_FILE       = 0x00000001,
			LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_DENY_DEFRAG_SET = 0x00000002,
			LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_FS_SYSTEM_FILE  = 0x00000004,
			LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_TXF_SYSTEM_FILE = 0x00000008,
		}
		enum {
			LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_MASK   = 0xff000000,
			LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_DATA   = 0x01000000,
			LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_INDEX  = 0x02000000,
			LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_SYSTEM = 0x03000000,
		}

		struct LOOKUP_STREAM_FROM_CLUSTER_ENTRY {
			DWORD OffsetToNext;
			DWORD Flags;
			LARGE_INTEGER Reserved;
			LARGE_INTEGER Cluster;
			WCHAR[1] FileName;
		}
		alias LOOKUP_STREAM_FROM_CLUSTER_ENTRY* PLOOKUP_STREAM_FROM_CLUSTER_ENTRY;

		struct FILE_TYPE_NOTIFICATION_INPUT {
			DWORD Flags;
			DWORD NumFileTypeIDs;
			GUID[1] FileTypeID;
		}
		alias FILE_TYPE_NOTIFICATION_INPUT* PFILE_TYPE_NOTIFICATION_INPUT;

		enum {
			FILE_TYPE_NOTIFICATION_FLAG_USAGE_BEGIN = 0x00000001,
			FILE_TYPE_NOTIFICATION_FLAG_USAGE_END   = 0x00000002,
		}

		mixin DEFINE_GUID!("FILE_TYPE_NOTIFICATION_GUID_PAGE_FILE", 0x0d0a64a1, 0x38fc, 0x4db8, 0x9f, 0xe7, 0x3f, 0x43, 0x52, 0xcd, 0x7c, 0x5c );
		mixin DEFINE_GUID!("FILE_TYPE_NOTIFICATION_GUID_HIBERNATION_FILE", 0xb7624d64, 0xb9a3, 0x4cf8, 0x80, 0x11, 0x5b, 0x86, 0xc9, 0x40, 0xe7, 0xb7 );
		mixin DEFINE_GUID!("FILE_TYPE_NOTIFICATION_GUID_CRASHDUMP_FILE", 0x9d453eb7, 0xd2a6, 0x4dbd, 0xa2, 0xe3, 0xfb, 0xd0, 0xed, 0x91, 0x09, 0xa9 );

}

enum IOCTL_VOLUME_BASE = 0x00000056;

enum IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS = CTL_CODE(IOCTL_VOLUME_BASE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS);

struct DISK_EXTENT {
	DWORD DiskNumber;
	LARGE_INTEGER StartingOffset;
	LARGE_INTEGER ExtentLength;
}
alias DISK_EXTENT* PDISK_EXTENT;

struct VOLUME_DISK_EXTENTS {
	DWORD NumberOfDiskExtents;
	DISK_EXTENT[ANYSIZE_ARRAY] Extents;
}
alias VOLUME_DISK_EXTENTS* PVOLUME_DISK_EXTENTS;

enum {
	IOCTL_VOLUME_ONLINE  = CTL_CODE(IOCTL_VOLUME_BASE, 2, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
	IOCTL_VOLUME_OFFLINE = CTL_CODE(IOCTL_VOLUME_BASE, 3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS),
}

//(NTDDI_VERSION >= NTDDI_WINXP)
	enum {
		IOCTL_VOLUME_IS_CLUSTERED       = CTL_CODE(IOCTL_VOLUME_BASE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS),
		IOCTL_VOLUME_GET_GPT_ATTRIBUTES = CTL_CODE(IOCTL_VOLUME_BASE, 14, METHOD_BUFFERED, FILE_ANY_ACCESS),
	}

	struct VOLUME_GET_GPT_ATTRIBUTES_INFORMATION {
		DWORDLONG GptAttributes;
	}
	alias VOLUME_GET_GPT_ATTRIBUTES_INFORMATION* PVOLUME_GET_GPT_ATTRIBUTES_INFORMATION;
